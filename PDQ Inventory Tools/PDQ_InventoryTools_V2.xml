<?xml version="1.0" encoding="utf-8"?>
<AdminArsenal.Export Code="PDQInventory" Name="PDQ Inventory" Version="19.0.40.0" MinimumVersion="15.0">
  <List type="list">
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine></CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>MOST USED</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>01:00:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>"C:\Program Files\uvnc bvba\UltraVNC\vncviewer.exe" $(Computer:TARGETHOSTNAME) /autoscaling /password &lt;password&gt;</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>NoShell</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0030</IconKey>
      <KeyGesture></KeyGesture>
      <Title>TightVNC         Auto</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>"C:\Program Files\SolarWinds\DameWare Mini Remote Control x64\DWRCC.exe" -h -m:$(Computer:TARGET) -md: -a:1 -c -x</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>NoShell</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0030</IconKey>
      <KeyGesture></KeyGesture>
      <Title>DameWare RC Auto</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>@Echo off
Echo Debut du Ping du poste $(Computer:TARGET) a l'IP $(Computer:TARGETIPADDRESS)

ping /t $(Computer:TARGETHOSTNAME)</CommandLine>
      <DefaultIconKey>Icon-CommandStep</DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>CloseShell</ShellOpenMode>
      <Mode>Command</Mode>
      <Description>Sends a persistent Ping to target machine. This will open a CMD window. To stop the ping either press CTRL+C or simply close the CMD window. This utility is great to use when a computer has been rebooted and you want to know the moment it comes back online.</Description>
      <IconKey>Stock0020</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Ping (Persistent)</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>Test-Connection $(Computer:TARGET) -Count ([int32]::MaxValue)</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>CloseShell</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0020</IconKey>
      <KeyGesture></KeyGesture>
      <Title>New Ping (Persistent)</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>explorer.exe "\\$(Computer:TARGETHOSTNAME)\C$"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>NoShell</ShellOpenMode>
      <Mode>Command</Mode>
      <Description>Attempts to connect via Windows Explorer (explorer.exe) to the target computer’s Windows directory. By default the %WINDIR% directory is shared as ADMIN$.</Description>
      <IconKey>Stock0895</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Ouvrir \\C$</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>#Recuperation Username distant :
$ComputerInfos = Get-WmiObject -Class Win32_ComputerSystem -Computername $(Computer:TARGET)
[String] ${stUserDomain},[String] ${stUserAccount} = $ComputerInfos.Username.split("\")

#On ouvre l'explorateur sur le dossier utilisateur ciblé
cmd.exe /c explorer.exe \\filer.adcha.local\users$\${stUserAccount}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>NoShell</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0895</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Ouvrir \\Filer\Users$\%username%</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>icacls "C:\Users\Public\Desktop" /grant "Tout le Monde":(f) /T</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock4030</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Autorisation Accès Bureau Public</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>LoggedOnUser</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine># This is required for Verbose to work correctly.
# If you don't want the Verbose message, remove "-Verbose" from the Parameters field.
[CmdletBinding()]
param ()

# On most OSes, HKEY_USERS only contains users that are logged on.
# There are ways to load the other profiles, but it can be problematic.
$Drives = Get-ItemProperty "Registry::HKEY_USERS\*\Network\*"

# See if any drives were found
if ( $Drives ) {

    ForEach ( $Drive in $Drives ) {

        # PSParentPath looks like this: Microsoft.PowerShell.Core\Registry::HKEY_USERS\S-1-5-21-##########-##########-##########-####\Network
        $SID = ($Drive.PSParentPath -split '\\')[2]

        [PSCustomObject]@{
            # Use .NET to look up the username from the SID
            Username            = ([System.Security.Principal.SecurityIdentifier]"$SID").Translate([System.Security.Principal.NTAccount])
            DriveLetter         = $Drive.PSChildName
            RemotePath          = $Drive.RemotePath

            # The username specified when you use "Connect using different credentials".
            # For some reason, this is frequently "0" when you don't use this option. I remove the "0" to keep the results consistent.
            ConnectWithUsername = $Drive.UserName -replace '^0$', $null
            SID                 = $SID
        }

    }

} else {

    Write-Verbose "No mapped drives were found"

}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock4030</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Get Lecteurs Réseaux - Logged on User</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine># This is required for Verbose to work correctly.
# If you don't want the Verbose message, remove "-Verbose" from the Parameters field.
[CmdletBinding()]
param ()

# On most OSes, HKEY_USERS only contains users that are logged on.
# There are ways to load the other profiles, but it can be problematic.
$Drives = Get-ItemProperty "Registry::HKEY_USERS\*\Network\*"

# See if any drives were found
if ( $Drives ) {

    ForEach ( $Drive in $Drives ) {

        # PSParentPath looks like this: Microsoft.PowerShell.Core\Registry::HKEY_USERS\S-1-5-21-##########-##########-##########-####\Network
        $SID = ($Drive.PSParentPath -split '\\')[2]

        [PSCustomObject]@{
            # Use .NET to look up the username from the SID
            Username            = ([System.Security.Principal.SecurityIdentifier]"$SID").Translate([System.Security.Principal.NTAccount])
            DriveLetter         = $Drive.PSChildName
            RemotePath          = $Drive.RemotePath

            # The username specified when you use "Connect using different credentials".
            # For some reason, this is frequently "0" when you don't use this option. I remove the "0" to keep the results consistent.
            ConnectWithUsername = $Drive.UserName -replace '^0$', $null
            SID                 = $SID
        }

    }

} else {

    Write-Verbose "No mapped drives were found"

}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0240</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Get Mapped Disk (All)</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>@ECHO OFF
CLS
setLocal EnableDelayedExpansion
REM The textfile to store the printers
SET textFile=C:\printers.txt
REM Clear the text file and start new
COPY /Y NUL !textFile! &gt;nul 2&gt;&amp;1


REM =================================================================================================================
REM Recuperation des Imprimantes pour tout utilisateur actuellement connecte.
REM =================================================================================================================
ECHO ==============================================================
REM ECHO Recherche des Utilisateurs qui sont connectes !
REM ECHO ==============================================================
REM ECHO.
FOR /F "tokens=*" %%G IN ('REG QUERY "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList"') DO (
    SET line=%%G
    FOR /F "tokens=3" %%X IN ('REG QUERY "HKLM\!line:~19!" /v "profileImagePath" 2^&gt;nul') DO (
        SET userPath=%%X
        SET userPath=!userPath:*C:\Users\=!

        SET isUser=true

        REM Specify users to filter out
        IF "!userPath!" == "Administrator" SET isUser=false
        IF "!userPath!" == "defaultuser0" SET isUser=false
        IF "!userPath!" == "Public" SET isUser=false
        IF "!isUser!" == "true" (
            IF EXIST "C:\users\!userPath!\" (
                REM Make sure the key actually exists
                REG QUERY "HKU\!line:~76!" &gt;nul 2&gt;&amp;1
                IF !ERRORLEVEL! EQU 0 (
                    ECHO Recuperation des Imprimantes pour !userPath!
                    ECHO !userPath!: &gt;&gt; !textFile!
                    REM Get all network printers
                    FOR /F "tokens=*" %%F IN ('REG QUERY "HKU\!line:~76!\Printers\Connections" 2^&gt;nul') DO (

                        REM Format the output to only contain the printer name,portname. Then print it to the text file.
                        SET newLine=%%F
                        SET output=!newLine:*Connections\=!
                        ECHO !output:,=\! &gt;&gt; !textFile!
                    )
                    ECHO.&gt;&gt;!textFile!
                )
            )
        )
    )
)
REM ECHO Les utilisateurs connectes sont maintenant traites.
REM ECHO .
REM =================================================================================================================
REM Recherche des Imprimantes réseaux des Utilisateurs déconnectés.
REM =================================================================================================================
REM ECHO ==============================================================
REM ECHO Recherche des Utilisateurs deconnectes.
REM ECHO ==============================================================
REM ECHO .
FOR /F "tokens=*" %%D IN ('DIR C:\Users\ /B') DO (
    SET line=%%D
    SET isUser=true

    REM Specify users to filter out
    IF "!line!" == "Administrator" SET isUser=false
    IF "!line!" == "defaultuser0" SET isUser=false
    IF "!line!" == "Public" SET isUser=false
    IF "!isUser!" == "true" (
        XCOPY "C:\Users\!line!\NTUSER.DAT" "C:\Users\!line!\NTUSER_TEMP.DAT*" /H /Q &gt;nul 2&gt;&amp;1
        IF !ERRORLEVEL! EQU 0 (
            REG LOAD "HKU\TempHive" "C:\Users\!line!\NTUSER_TEMP.DAT" &gt;nul 2&gt;&amp;1

            REM Make sure the key actually exists
            REG QUERY "HKU\TempHive\Printers\Connections" &gt;nul 2&gt;&amp;1
            IF !ERRORLEVEL! EQU 0 (

                REM Get all network printers
                REM ECHORecuperation des Imprimantes pour !userPath!
                ECHO !line!: &gt;&gt; !textFile!
                FOR /F "tokens=*" %%F IN ('REG QUERY "HKU\TempHive\Printers\Connections" 2^&gt;nul') DO (

                    REM Format the output to only contain the printer name. Then print it to the text file.
                    SET newLine=%%F
                    SET output=!newLine:*Connections\=!
                    ECHO - !output:,=\! &gt;&gt; !textFile!
                )
                ECHO.&gt;&gt;!textFile!
            )

            REG UNLOAD "HKU\TempHive" &gt;nul 2&gt;&amp;1
            DEL /Q /A:H "C:\Users\!line!\NTUSER_TEMP.DAT"
        )
    )
)

REM =================================================================================================================
REM Récupération des imprimantes installées localement.
REM =================================================================================================================
ECHO ==============================================================
ECHO Recherche des imprimantes locales.
ECHO ==============================================================
ECHO.
ECHO Local Printers:&gt;&gt;!textFile!
FOR /F "tokens=*" %%a in ('WMIC PRINTER GET NAME') do (
    SET printer=%%a
    IF NOT "!printer:~0,2!" == "\\" (
        IF NOT "!printer:~0,4!" == "Name" (
            ECHO.!printer! &gt;&gt; !textFile!
        )
    )
)
ENDLOCAL
TYPE \\%COMPUTERNAME%\C$\printers.txt
pause</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Icon-CommandStep</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Get Mapped Printers</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (1)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine></CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>FREQUENTLY USED</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>REG ADD "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v "AutoAdminLogon" /f /d "1"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>NoShell</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0610</IconKey>
      <KeyGesture></KeyGesture>
      <Title>AutoAdminLogon - Activation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>REG ADD "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v "AutoAdminLogon" /f /d "0"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>NoShell</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0620</IconKey>
      <KeyGesture></KeyGesture>
      <Title>AutoAdminLogon - Désactivation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>ScanAfter</ScanAfter>
      <ScanProfileId value="13" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>$description = Read-Host 'Entrez la description voulue ' 
Set-ADComputer $(Computer:TARGET) -replace:@{"description"="$($description)"}

#Scan after
Invoke-Command -ScriptBlock {pdqinventory ScanComputers -Computers "$(Computer:TARGET)" -ScanProfile "AD Infos"}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0120</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Changement Description AD</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>#===================
#Script pour ajouter un poste à un groupe AD
#===================
#Récupération des groupes d'un poste distant depuis PDQ
$Computer = "$(Computer:TARGET)"
#Message
Write-Host "Le poste '$Computer' est membre des groupes :" -ForegroundColor Cyan

#On récupère les groupes du poste
$ADComputerInfo = Get-ADComputer $Computer -Properties *
If([string]::IsNullOrEmpty($ADComputerInfo.MemberOf) -eq $True) {
Write-Host "Aucun Groupe !"
}
Else {
#On corrige l'affichage des groupes pour ne récupérer que le nom du groupe
$Inputstring = $ADComputerInfo.MemberOf
$split = $Inputstring.split("`n")
$result = Foreach ($line in $split) {
$input = $line.split(",")[0]
$output = $input -replace 'CN='
$output
}
$result
}
Pause

#On cherche les groupes AD et on affiche un menu de sélection:
$Groupes = Get-ADGroup -Filter "name -like 'G_ordinateurs*'"                    
$Menu = @{}
for ($Valeur=1;$Valeur -le $Groupes.count; $Valeur++) 
{Write-Host "$Valeur= $($Groupes[$Valeur-1].name)" 
$Menu.Add($Valeur,($Groupes[$Valeur-1].name))}
[int]$Choix = Read-Host 'Choisir le Groupe AD: '
#Detection de choix non null pour poursuivre
If($Choix -eq "0") {
Write-Host "[INFO] Aucun groupe de choisi, le poste ne sera pas ajoute a un groupe, Abort ..!" -ForegroundColor Red
}
Else {
#On enregistre la sélection du menu
$Selection = $Menu.Item($Choix)

#On recré les Distinguished Names:
#Identity:
$ADUserInfo = Get-ADComputer "$Computer" -Properties *
$DistingName = $ADUserInfo.DistinguishedName
$Identity = $DistingName
#MemberOf:
$GroupName = 'G_ordinateurs*'
$DistingName2 = $ADGroupInfo.DistinguishedName
#2nd menu pour correspondance DistinguishedName avec Name du menu d'avant:
$Menu2 = @{}
$ADGroupInfo = Get-ADGroup -Filter "name -like 'G_ordinateurs*'"              
for ($Valeur2=1;$Valeur2 -le $ADGroupInfo.count; $Valeur2++)
{Write-Host "$Valeur2= $($ADGroupInfo[$Valeur2-1].distinguishedname)" 
$Menu2.Add($Valeur2,($ADGroupInfo[$Valeur2-1].distinguishedname))}
$Choix2 = $Menu2.Item($Choix)

#On ajoute le poste au groupe choisi
Add-ADPrincipalGroupMembership -Identity:"$Identity" -MemberOf:"$Choix2" -Verbose
Write-Host ""
Write-Host "Le poste '$Computer' a bien ete ajoute au Groupe AD '$Selection', OK!" -ForegroundColor Green
Write-Host ""

#On re-récupère les groupes du poste
$ADComputerInfo = Get-ADComputer $Computer -Properties *
If([string]::IsNullOrEmpty($ADComputerInfo.MemberOf) -eq $True) {
Write-Host "Aucun Groupe !"
}
Else {
#On corrige l'affichage des groupes pour ne récupérer que le nom du groupe
$Inputstring = $ADComputerInfo.MemberOf
$split = $Inputstring.split("`n")
$result = Foreach ($line in $split) {
$input = $line.split(",")[0]
$output = $input -replace 'CN='
$output
}
Write-Host "Le poste '$Computer' est donc maintenant membre des groupes :" -ForegroundColor Cyan
$result
Write-Host ""
}
Start-Sleep 4

#Scan PDQ Inventory
Invoke-Command -ScriptBlock {pdqinventory ScanComputers -Computers "$Computer" -ScanProfile "AD Infos"}
}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0120</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Ajout Computer to Groupe AD</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>#Script pour recuperation des groupes sur lesquels une imprimante est appliquee
#Chemin du fichier de la GPO
$path = "\\DC\c$\Windows\SYSVOL\domain\Policies\{&lt;INSERT GPO ID HERE&gt;}\User\Preferences\Printers\Printers.xml"
if (Test-Path $path -ErrorAction SilentlyContinue)
                {
                    [xml]$xml = Get-Content $path #| Select xml
                    #On classe par ordre alphabetique
                    $order = @(
                                @{ Expression = 'Name'; Ascending = $true }
                               )
                    $sort = $xml.Printers.SharedPrinter | Select Name,Filters | Sort-Object $order
                    $sort | ForEach-Object {
                    If ($_.Name.StartsWith("Copieur")) {
                    [PSCustomObject]@{
                    'Imprim' = $_.Name 
                    'Groupe'    = $_.Filters.FilterGroup.Name
                    } 
                    #Export sous forme de CSV
                    #| Export-csv -Path "C:\temp\test.csv" -Append
                    }}}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Icon-PowerShell</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Get Printers-Groups</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>#===================
#Script pour supprimer un poste d'un groupe AD
#===================
$Computer = "$(Computer:TARGET)"
#Création variable Identity pour commande finale
$ADUserInfo = Get-ADComputer "$Computer" -Properties *
$DistingName = $ADUserInfo.DistinguishedName
$Identity = $DistingName

#Récupération des groupes d'un poste distant depuis PDQ
#On récupère les groupes du poste
$ADComputerInfo = Get-ADComputer $Computer -Properties *
If ([string]::IsNullOrEmpty($ADComputerInfo.MemberOf) -eq $False) {
#On corrige l'affichage des groupes pour ne récupérer que le nom du groupe
$Inputstring = $ADComputerInfo.MemberOf
$split = $Inputstring.split("`n")
$result = Foreach ($line in $split) {
$input = $line.split(",")[0]
$output = $input -replace 'CN='
$output
}
Write-Host "Le poste '$Computer' est membre des groupes :" -ForegroundColor Cyan

$Groupes = $Result #$ADComputerInfo.MemberOf
$Menu = @{}
for ($Valeur=1;$Valeur -le $Groupes.count; $Valeur++) 
{Write-Host "$Valeur= $($Groupes.split("`n")[$Valeur-1])" 
$Menu.Add($Valeur,($Groupes.split("`n")[$Valeur-1]))}
[int]$Choix = Read-Host 'Choisir le Groupe AD a supprimer'

#On enregistre la sélection du menu
$Selection = $Menu.Item($Choix)
$Selection

#On ajoute le poste au groupe choisi:
Remove-ADPrincipalGroupMembership -Identity:"$Identity" -MemberOf:"$Selection" -Verbose -Confirm:$false
Write-Host ""
Write-Host "Le poste '$Computer' a ete supprime du Groupe AD '$Selection', OK!" -ForegroundColor Green
Write-Host ""

#On re-récupère les groupes du poste
$ADComputerInfo = Get-ADComputer $Computer -Properties *
If([string]::IsNullOrEmpty($ADComputerInfo.MemberOf) -eq $True) {
Write-Host "Aucun Groupe !"
}
Else {
#On corrige l'affichage des groupes pour ne récupérer que le nom du groupe
$Inputstring = $ADComputerInfo.MemberOf
$split = $Inputstring.split("`n")
$result = Foreach ($line in $split) {
$input = $line.split(",")[0]
$output = $input -replace 'CN='
$output
}
Write-Host "Le poste '$Computer' est donc maintenant membre des groupes :" -ForegroundColor Cyan
$result
Write-Host ""
}
Start-Sleep 4

#Scan PDQ Inventory
Invoke-Command -ScriptBlock {pdqinventory ScanComputers -Computers "$Computer" -ScanProfile "AD Infos"}
}
Else { 
Write-Host "[INFO] Le poste '$Computer' n'est membre d'aucun Groupe, Abort ..!" -ForegroundColor Yellow
Write-Host ""
}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0120</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Suppr Computer from Groupe AD</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>#Récupération des groupes d'un poste distant depuis PDQ
$Computer = "$(Computer:TARGET)"
#Message
Write-Host "Le poste '$Computer' est membre des groupes :" -ForegroundColor Cyan

#On récupère les groupes du poste
$ADComputerInfo = Get-ADComputer $Computer -Properties *
If([string]::IsNullOrEmpty($ADComputerInfo.MemberOf) -eq $True) {
Write-Host "Aucun Groupe !"
}
Else {
#On corrige l'affichage des groupes pour ne récupérer que le nom du groupe
$Inputstring = $ADComputerInfo.MemberOf
$split = $Inputstring.split("`n")
$result = Foreach ($line in $split) {
$input = $line.split(",")[0]
$output = $input -replace 'CN='
$output
}
$result
}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0120</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Get Computer's Groupes AD</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>@Echo off
Echo Refresh Group Policy settings on $(Computer:TARGET)
Echo If it asks to reboot, just say no.

psexec \\$(Computer:TARGETHOSTNAME) -accepteula cmd /c "echo n | (gpupdate)"</CommandLine>
      <DefaultIconKey>Icon-Hardware</DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Icon-CommandStep</IconKey>
      <KeyGesture></KeyGesture>
      <Title>GPUpdate (psexec)</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>System</CustomToolType>
      <CommandLine>&lt;#
#Script pour chercher un nom d'ordinateur dans le DNS
#Cherche sur plusieurs serveurs
#Cherche dans chaque zone
#Alex
#&gt; 

cls
$work_dir = get-location | select -ExpandProperty Path
$work_dir = $work_dir + "\"
#run again with elevated permissions
if (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) 
    { 
    #Start-Process powershell.exe "-NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`"" -WorkingDirectory $work_dir -Verb RunAs; exit
    Start-Process powershell.exe -ArgumentList "-File $PSCommandPath", $work_dir -Verb RunAs 
    exit
    }
#--------------------------------------------------------------

#------------------prompt for computer name--------------------
$computername = read-host "Saisir une partie du Nom ou de l'IP "
#$computername = "computername"
#--------------------------------------------------------------

#-----------------------search in domain-----------------------
#---loop through all dhcps
$DNSServers = "DC1.adcha.local","DC2.adcha.local"
ForEach ($DNS in $DNSServers){
$Zones = @(Get-DnsServerZone -ComputerName $DNS)
ForEach ($Zone in $Zones) {
 Get-DnsServerResourceRecord -ComputerName "$DNS" -ZoneName $Zone.ZoneName | where {($_.Hostname -like "*$computername*") -or ($_.RecordData.IPv4Address -like "*$computername*")} |
    Select HostName,RecordType,@{l="Server";e={$DNS}}, @{Name='RecordData';Expression={$_.RecordData.IPv4Address}},Timestamp | format-table -AutoSize
}
}
#--------------------------------------------------------------

#-----------------------wait for any key-----------------------
read-host "press any key to continue"
#Write-Host "Press any key to continue ..."
#$x = $host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
#--------------------------------------------------------------</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock1030</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Check DNS Record</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>System</CustomToolType>
      <CommandLine>&lt;#------------------------------------------------------------------------------------------
- A script to look for a computer name in all dhcp servers in domain.                      -
- The script will loop through all dhcps identified by Get-DhcpServerInDC.                 -
- For some reason some of the servers identified fail to respond to Get-DhcpServerv4Scope. -
-                                                                                          -
-Tsvi Keren                                                                                -
------------------------------------------------------------------------------------------#&gt;

#--------------------------elevate-----------------------------
cls
$work_dir = get-location | select -ExpandProperty Path
$work_dir = $work_dir + "\"
#run again with elevated permissions
if (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) 
    { 
    #Start-Process powershell.exe "-NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`"" -WorkingDirectory $work_dir -Verb RunAs; exit
    Start-Process powershell.exe -ArgumentList "-File $PSCommandPath", $work_dir -Verb RunAs 
    exit
    }
#--------------------------------------------------------------

#------------------prompt for computer name--------------------
$computername = read-host "Saisir une partie du Nom "
#$computername = "computername"
#--------------------------------------------------------------

#-----------------------search in domain-----------------------
#---loop through all dhcps
$DNSServers = "DC1.adcha.local","DC2.adcha.local"
ForEach ($DNS in $DNSServers){
$Zones = @(Get-DnsServerZone -ComputerName $DNS)
ForEach ($Zone in $Zones) {
 Get-DnsServerResourceRecord -ComputerName "$DNS" -ZoneName $Zone.ZoneName | where {$_.Hostname -like "*$computername*"} |
    Select HostName,RecordType,@{l="Server";e={$DNS}}, @{Name='RecordData';Expression={$_.RecordData.IPv4Address}},Timestamp | format-table -AutoSize
}
}
#--------------------------------------------------------------

#-----------------------wait for any key-----------------------
read-host "press any key to continue"
#Write-Host "Press any key to continue ..."
#$x = $host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
#--------------------------------------------------------------</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock1030</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Check DHCP Leases</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Set-ItemProperty -Path REGISTRY::HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System -Name ConsentPromptBehaviorAdmin -Value 0</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Icon-PowerShell</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Désactivation UAC - Controle compte</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>##################################################
#
# Check AD user and see if anything seems off
#
# Change the $GroupListAlert if you want it to
# warn you, and the $Domains if you have split
# admin / student domains
# 
##################################################

$Good = "Green"
$Bad = "Red"
$OtherName = "Magenta"
$Iffy = "Yellow"
$GroupListAlert = ("SPECIAL GROUP TO WARN ABOUT - ou=company, ou=.com etc")

# Ask for a login name and try to pull information, loop if we error when trying
Do
{

    $Domain = "DC1.adcha.local" #Read-Host "[a]dmin or [s]tudent (a)"
    #If ($Domain -eq "s")
    #{
    #    $Domain = "DC1"
    #}
    #Else
    #{
    #    $Domain = "DC2"
    #}

    $ComputerInfos = Get-WmiObject -Class Win32_ComputerSystem -Computername $(Computer:TARGET)
    [String] ${stUserDomain},[String] ${stUserAccount} = $ComputerInfos.Username.split("\")
    $LoginName = [String] ${stUserAccount}
    #$LoginName =  $env:USERNAME 
    #$LoginName = $LoginName.Trim()
    #$LoginName = $LoginName.Replace(" ", ".") 
    $ADUserInfo = Get-ADUser $LoginName -Properties * -Server $Domain

} While (!$?)
$Response = "y"

# If we do, load the modules
If ($Response -eq "n")
{
\\sccm2012\e$\SCCM_Repository\Software\Scripts\CheckADUser\Connect.ps1
}

$Today = Get-Date


# Show basic stuff
#Check le Nom de l'utilisateur :
Write-Host "Nom Utilisateur:       " -NoNewline
Write-Host $ADUserInfo.DisplayName -ForegroundColor Cyan

#_________________________
#Check le nom de login, nom utiliser pour la connexion à l'ordinateur :
Write-Host "Nom de Login:          " -NoNewline
Write-Host $ADUserInfo.SAMAccountName -ForegroundColor Cyan

#_________________________
#Check si l'utilisateur peut changer le mot de passe ou pas :
Write-Host "CannotChangePassword: " $ADUserInfo.CannotChangePassword

#_________________________
#Check la date de creation du compte utilisateur :
Write-Host "Cree le:               "  -NoNewline
Write-Host $ADUserInfo.Created -ForegroundColor Cyan

#_________________________
#Check la dernière modicication du compte AD :
Write-Host "Modifie le:           " $ADUserInfo.Modified

#_________________________
#Check si un emplacement physique est indiqué ou pas :
If ($ADUserInfo.Office -eq $null)
{
    $Colour = $Good
Write-Host "Bureau:                -NC-"
}
Else
{
Write-Host "Bureau:               "  -NoNewline
Write-Host $ADUserInfo.Office -ForegroundColor Cyan
}

#_________________________
#Check si une adresse Mail est renseigner ou pas :
If ($ADUserInfo.Mail -eq $null)
{
    $Colour = $Good
Write-Host "Mail:                  -NC-" -ForegroundColor $Bad
}
Else
{
Write-Host "Mail:                  "  -NoNewline
Write-Host $ADUserInfo.Mail -ForegroundColor Cyan
}

#_________________________
#Check si un numero de téléphone est renseigne ou pas :
If ($ADUserInfo.OfficePhone -eq $null)
{
    $Colour = $Good
Write-Host "Téléphone:             " -NoNewline
Write-Host "-NC-" -ForegroundColor $Bad
}
Else
{
Write-Host "Telephone:             "  -NoNewline
Write-Host $ADUserInfo.OfficePhone -ForegroundColor Cyan
}

#_________________________
#Check si le poste au sein du CHA est renseigne ou pas :
If ($ADUserInfo.Title)
{
    $Colour = "Blue"
Write-Host "Poste occupé:          " -NoNewline
Write-Host $ADUserInfo.Title -ForegroundColor $Colour
}
Else
{ 
Write-Host "Poste occupe:          " -NoNewline
Write-Host "-NC-"
}

#_________________________
#Check le nombre d'authentification via l'AD :
Write-Host "Long Count:           " $ADUserInfo.logonCount

#_________________________
#Check si l'utilisateur a un chemin de profil :
If ($ADUserInfo.ProfilePath)
{
    $Colour = $Good
Write-Host "Chemin Profil:         " -NoNewline
Write-Host $ADUserInfo.ProfilePath -ForegroundColor $Colour
}
Else
{
    $Colour = $Bad
Write-Host "Chemin Profil:         " -NoNewline
Write-Host "Pas de ProfilePath! Pas bon!" -ForegroundColor $Colour
 }

#_________________________
#Check si l utilisateur a un autre nom (Nom de jeune fille)
If ($ADUserInfo.OtherName)
{
    $Colour = $OtherName
Write-Host "Autre Nom:             " -NoNewline
Write-Host $ADUserInfo.OtherName -ForegroundColor $Colour
}
Else
{
    $Colour = $Bad
Write-Host "Autre Nom:             -NC-" -NoNewline
Write-Host $ADUserInfo.OtherName -ForegroundColor $Colour
}

#_________________________
# Check if the account is enabled, color response
If ($ADUserInfo.Enabled)
{
    $Colour = $Good
}
Else
{
    $Colour = $Bad
}
Write-Host "Compte Active ?    :   " -NoNewline
Write-Host $ADUserInfo.Enabled -ForegroundColor $Colour 

#_________________________
# Check if account is locked out and color accordingly
If ($ADUserInfo.LockedOut)
{
    $Colour = $Bad
}
Else
{
    $Colour = $Good
}
Write-Host "Compte verrouille ?:   " -NoNewline
Write-Host $ADUserInfo.LockedOut -ForegroundColor $Colour

#_________________________
# If the account is expired (also check for null as that is &lt; today)
If ($ADUserInfo.AccountExpirationDate -lt $Today -and $ADUserInfo.AccountExpirationDate -ne $null)
{
    $Colour = $Good
Write-Host "Compte  expire le  :   " -NoNewline
Write-Host $ADUserInfo.AccountExpirationDate -ForegroundColor $Colour
   
}
Else
{
    $Colour = $Bad
Write-Host "Compte  expire le  :   " -NoNewline
Write-Host $ADUserInfo.AccountExpirationDate -ForegroundColor $Colour
}

#_________________________
#Check si le compte expire ou jamais :
If ($ADUserInfo.accountExpires -eq "0")
{
    $Colour = $Good
Write-Host "Compte  expire:        " -NoNewline
Write-Host "False" -ForegroundColor $Colour
}
Else
{
    $Colour = $Bad
Write-Host "Compte  expire:        " -NoNewline
Write-Host "True" -ForegroundColor $Colour

}

#_________________________
# Have they logged in in the last 7 days
If ($ADUserInfo.LastLogonDate.AddDays(7) -lt $Today)
{
    $Colour = $Iffy
}
Else
{
    $Colour = $Good
}
Write-Host "Dernier Logon:         " -NoNewline
Write-Host $ADUserInfo.LastLogonDate -ForegroundColor $Colour

#_________________________
# Check PasswordLastSet isn't null (to prevent errors)
If ($ADUserInfo.PasswordLastSet -eq $Null)
{
    $Colour = $Iffy
    Write-Host "MDP parametre le:       " -NoNewline
    Write-Host "NULL" -ForegroundColor $Colour
}
Else
{
    # If they set their password over 90 days ago, OR in the last day
    If ($ADUserInfo.PasswordLastSet.AddDays(90) -lt $Today -or $ADUserInfo.PasswordLastSet.AddDays(1) -gt $Today)
    {
        $Colour = $Iffy
    }
    Else
    {
        $Colour = $Good
    }
    Write-Host "MDP parametre le:      " -NoNewline
    Write-Host $ADUserInfo.PasswordLastSet -ForegroundColor $Colour

    # Is their password expired (based on GPO of 90 days)
    If ($ADUserInfo.PasswordLastSet.AddDays(90) -lt $Today)
    {
        $Colour = $Bad
    }
    Else
    {
        $Colour = $Good
    }
    Write-Host "MDP expire le:         " -NoNewline
    Write-Host $ADUserInfo.PasswordLastSet.AddDays(90) -ForegroundColor $Colour
}

#_________________________
# Ckeck si le mot de passe n'expire jamais ou pas :
If ($ADUserInfo.PasswordNeverExpires)
{
    $Colour = $Good
}
Else
{
    $Colour = $Bad
}
Write-Host "MDP n'expire jamais?:  " -NoNewline
Write-Host $ADUserInfo.PasswordNeverExpires -ForegroundColor $Colour
Write-Host "User dans l'OU:        " -NoNewline
Write-Host $ADUserInfo.CanonicalName -ForegroundColor Cyan
Write-Host "Membre des Groupes:         "

# Check the groups they are in
ForEach ($GroupList in $ADUserInfo.MemberOf)
{
    # If it is Deny Logins, colour it!
    If ($GroupListAlert -contains $GroupList)
    {
        Write-Host "                  " $GroupList -ForegroundColor $Bad
    }
    Else
    {
        Write-Host "                  " $GroupList
    }
}


    $MSUser.Licenses.ServiceStatus | FT -AutoSize

    # And tidy up and close the session down
    \\sccm2012\e$\SCCM_Repository\Software\Scripts\CheckADUser\Disconnect.ps1</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0510</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Get AD User Infos</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>System</CustomToolType>
      <CommandLine>#Faire apparaitre le nom d'utilisateur saisie pour vérification que ce soit la bonne personne
Write-Output "Executing on: `n   $env:computername"
@'
Description:
   Reset password, unlock account, and set password to change at next logon.
'@
$Username = Read-Host "Nom d'utilisateur a reset"
$NewPassword = Read-Host -AsSecureString "Nouveau Mot de Passe"
Set-ADAccountPassword -Reset -NewPassword $NewPassword -Identity $Username -verbose
Unlock-ADAccount -Identity $Username -verbose
#Demande si on change le mot de passe au prochain Logon
$decision = $Host.UI.PromptForChoice('Changement au prochain Login', 'L utilisateur devra-t-il changer le mot de passe au prochain Login ?', @('&amp;Oui'; '&amp;Non'), 1)
if ($decision -eq 0) {
    Set-ADUser -Identity $Username -ChangePasswordAtLogon $True -verbose
    Write-Host "Le mot de passe sera change a la prochaine ouverture de session de $Username"
} else {
    Write-Host "Le mot de passe ne sera pas change a la prochaine ouverture de session de $Username, OK"
}
Start-Sleep -s 4</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>CloseShell</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0510</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Reset AD User Password (ChangePasswordAtLogon)</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>#Recuperation Username distant :
$user = (Get-WmiObject -ComputerName $(Computer:TARGETHOSTNAME) -Class win32_computersystem).username.split("\")[1]

#On cherche et affiche les groupes AD :
$ADUserInfo = Get-ADUser $user -Properties *
Write-Host "L'utilisateur $user est membre des groupes :" -ForegroundColor Cyan
$ADUserInfo.MemberOf</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0520</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Get AD User Groupes</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>Enter-PSSession $(Computer:TARGETHOSTNAME)</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Icon-PowerShell</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Enter-PSSession</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (6)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Win10</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>Function Disable-UAC {
    Write-host 'Lowering UAC level...' -NoNewline
    Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -Name "ConsentPromptBehaviorAdmin" -Type DWord -Value 0
    Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -Name "PromptOnSecureDesktop" -Type DWord -Value 0
    write-host 'Done'
}
Disable-UAC</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Disable UAC</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>Function Disable-Defender {
    Write-Host "Disabling Windows Defender...." -NoNewline
    If (!(Test-Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender")) {
        New-Item -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender" -Force | Out-Null
    }
    Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender" -Name "DisableAntiSpyware" -Type DWord -Value 1
    If ([System.Environment]::OSVersion.Version.Build -eq 14393) {
        Remove-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" -Name "WindowsDefender" -ErrorAction SilentlyContinue
    }
    ElseIf ([System.Environment]::OSVersion.Version.Build -ge 15063) {
        Remove-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" -Name "SecurityHealth" -ErrorAction SilentlyContinue
    }
    write-host 'Done'

    Write-Host "Disabling Windows Defender Cloud..." -nonew
    If (!(Test-Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet")) {
        New-Item -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" -Force | Out-Null
    }
    Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" -Name "SpynetReporting" -Type DWord -Value 0
    Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" -Name "SubmitSamplesC
    onsent" -Type DWord -Value 2
    write-host 'Done'
}
Disable-Defender</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Disable Windows Defender</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>function Update-PrivacySettings {
    write-host 'Updating privacy settings....' -NoNewline

    # Privacy: SmartScreen Filter for Store Apps: Disable
    If (-Not (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\AppHost")) {
        New-Item -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\AppHost -Force | Out-Null
    }
    Set-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\AppHost -Name EnableWebContentEvaluation -Type DWord -Value 0
    If (-Not (Test-Path "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\AppHost")) {
        New-Item -Path HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\AppHost -Force | Out-Null
    }
    Set-ItemProperty -Path HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\AppHost -Name EnableWebContentEvaluation -Type DWord -Value 0

    # WiFi Sense: HotSpot Sharing: Disable
    If (-Not (Test-Path "HKLM:\Software\Microsoft\PolicyManager\default\WiFi\AllowWiFiHotSpotReporting")) {
        New-Item -Path HKLM:\Software\Microsoft\PolicyManager\default\WiFi\AllowWiFiHotSpotReporting -Force | Out-Null
    }
    Set-ItemProperty -Path HKLM:\Software\Microsoft\PolicyManager\default\WiFi\AllowWiFiHotSpotReporting -Name value -Type DWord -Value 0
    If (-Not (Test-Path "HKCU:\Software\Microsoft\PolicyManager\default\WiFi\AllowWiFiHotSpotReporting")) {
        New-Item -Path HKCU:\Software\Microsoft\PolicyManager\default\WiFi\AllowWiFiHotSpotReporting -Force | Out-Null
    }
    Set-ItemProperty -Path HKCU:\Software\Microsoft\PolicyManager\default\WiFi\AllowWiFiHotSpotReporting -Name value -Type DWord -Value 0

    # WiFi Sense: Shared HotSpot Auto-Connect: Disable
    If (-Not (Test-Path "HKLM:\Software\Microsoft\PolicyManager\default\WiFi\AllowAutoConnectToWiFiSenseHotspots")) {
        New-Item -Path HKLM:\Software\Microsoft\PolicyManager\default\WiFi\AllowAutoConnectToWiFiSenseHotspots -Force | Out-Null
    }
    Set-ItemProperty -Path HKLM:\Software\Microsoft\PolicyManager\default\WiFi\AllowAutoConnectToWiFiSenseHotspots -Name value -Type DWord -Value 0
    If (-Not (Test-Path "HKCU:\Software\Microsoft\PolicyManager\default\WiFi\AllowAutoConnectToWiFiSenseHotspots")) {
        New-Item -Path HKCU:\Software\Microsoft\PolicyManager\default\WiFi\AllowAutoConnectToWiFiSenseHotspots -Force | Out-Null
    }
    Set-ItemProperty -Path HKCU:\Software\Microsoft\PolicyManager\default\WiFi\AllowAutoConnectToWiFiSenseHotspots -Name value -Type DWord -Value 0

    # Disable Telemetry (requires a reboot to take effect)
    If (-Not (Test-Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection")) {
        New-Item -Path HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection -Force | Out-Null
    }
    Set-ItemProperty -Path HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection -Name AllowTelemetry -Type DWord -Value 0
    If (-Not (Test-Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\DataCollection")) {
        New-Item -Path HKCU:\SOFTWARE\Policies\Microsoft\Windows\DataCollection -Force | Out-Null
    }
    Set-ItemProperty -Path HKCU:\SOFTWARE\Policies\Microsoft\Windows\DataCollection -Name AllowTelemetry -Type DWord -Value 0
    Get-Service DiagTrack, Dmwappushservice | Stop-Service | Set-Service -StartupType Disabled
    write-host 'Done'
}
Update-PrivacySettings</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Update Privacy Settings</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <SeparatorComputerTool>
          <Description></Description>
          <IconKey></IconKey>
          <KeyGesture></KeyGesture>
          <Title>Separator (1)</Title>
          <TypeName>SeparatorComputerTool</TypeName>
        </SeparatorComputerTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>function Say-Text {
    param ([Parameter(Mandatory=$true, ValueFromPipeline=$true)] [string] $Text)
    [Reflection.Assembly]::LoadWithPartialName('System.Speech') | Out-Null   
    $object = New-Object System.Speech.Synthesis.SpeechSynthesizer 
    $object.Speak($Text) 
} 
Say-Text "Hey boy"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Say Text</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>function prompt
{
    # Determine if Powershell is running as Administrator
    $currentPrincipal = New-Object Security.Principal.WindowsPrincipal( [Security.Principal.WindowsIdentity]::GetCurrent() )
    $isAdmin = $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

    $leftCharCount = 0
    $middleCharCount = 0
    $rightCharCount = 0

    # Grab current git branch
    $isGitRepo = ""
    if(Test-Path .git) {
        $isGitRepo = "yeah"
    }

    # Grab current loaction
    $location = $(get-location).Path;

    Write-Host ("")
    Write-Host (" [ ") -nonewline -foregroundcolor White -backgroundcolor DarkBlue
    $leftCharCount += 3
    Write-Host ([Environment]::UserName) -nonewline -foregroundcolor White -backgroundcolor DarkBlue
    $leftCharCount += [Environment]::UserName.length
    if ($isAdmin) {
        Write-Host ("†") -nonewline -foregroundcolor DarkYellow -backgroundcolor DarkBlue
        $leftCharCount += 1
    }
    Write-Host (" @") -nonewline -foregroundcolor Gray -backgroundcolor DarkBlue
    $leftCharCount += 2
    Write-Host ([System.Net.Dns]::GetHostName()) -nonewline -foregroundcolor White -backgroundcolor DarkBlue
    $leftCharCount += [System.Net.Dns]::GetHostName().length
    Write-Host (" ] ") -nonewline -foregroundcolor White -backgroundcolor DarkBlue
    $leftCharCount += 3
    Write-Host ("▓▓▒▒░░") -nonewline
    $leftCharCount += 6

    if ($isGitRepo) {
        # Grab current branch
        $git_branchName = "";
        git branch | foreach {
            if ($_ -match "^\* (.*)") {
                $git_branchName += $matches[1]
            }
        }

        # Check if workspace has changes
        $git_changes = 0
        $git_changesDisplay = ""
        git status --porcelain | foreach {
            $git_changes++
        }
        if ($git_changes -gt 0) {
            $git_changesDisplay = "•"
        }

        # Check if pushes or pulls available
        $git_pushes = ""
        $git_pulls = ""
        git status -sb | foreach {
            if ($_ -match "ahead (\d+)") {
                $git_pushes = " ↑" + $matches[1]
            }
            if ($_ -match "behind (\d+)") {
                $git_pulls = " ↓" + $matches[1]
            }
        }

        # Calculate length of git display (by making a new string)
        $rightCharCount = "[ Ѱ$($git_changesDisplay) $($git_branchName)$($git_pushes)$($git_pulls) ] ".length

        # Write spaces for padding, so that the display is right-aligned
        $middleCharCount = $ui.WindowSize.Width - $leftCharCount - $rightCharCount
        for ($i=1; $i -le $middleCharCount; $i++)
        {
            Write-Host (" ") -nonewline
        }

        # Actually output the git display
        Write-Host ("[ ") -nonewline
        Write-Host ("Ѱ") -nonewline -foregroundcolor DarkGray
        Write-Host ($git_changesDisplay) -nonewline -foregroundcolor DarkGreen
        Write-Host (" $git_branchName") -nonewline
        Write-Host ("$git_pushes") -nonewline -foregroundColor Green
        Write-Host ("$git_pulls") -nonewline -foregroundColor Red
        Write-Host (" ] ") -nonewline
    } else {
        # No alternate display, just send a newline
        Write-Host ("")
    }

    Write-Host ("»") -nonewline -foregroundcolor DarkGreen
    if ($location -eq "C:\Users\$([Environment]::UserName)") {
        Write-Host ("~\") -nonewline
    } else {
        Write-Host ($location) -nonewline
    }
    Write-Host ("»") -nonewline -foregroundcolor DarkGreen

    return " "
}
Prompt</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Cool Powershell Prompt #BE CAREFUL</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (1)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Activation ; Licence</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>c:
cd c:\windows\system32
cscript.exe slmgr.vbs /skms kmsserv.domain
cscript.exe slmgr.vbs /upk
cscript.exe slmgr.vbs /ipk &lt;LICENCE NUMBERS&gt;
cscript.exe slmgr.vbs /ato</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Stock0610</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Activation Windows</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>@echo off

REM | =============================================
REM | CHECK ACTIVATION STATUS - WINDOWS AND OFFICE
REM | BACKEND SCRIPT
REM | =============================================
REM | Purpose: 
REM | - Check for activation status of the following products:
REM | -- Microsoft Windows
REM | -- Microsoft Office 2016, including
REM | --- Microsoft Project 2016
REM | --- Microsoft Visio 2016
REM | - Output results to PDQ Deploy deployment log.
REM | Requirements:
REM | - None
REM | Author: Unknown, Tim Dunn
REM | Organisation: TAFEITLAB

REM | ================
REM | VERSION HISTORY
REM | ================ 
REM | -- 2019-03-11 --
REM | Created script to replace prior similar utility. 
REM | ----------------
REM | -- 2019-03-27--
REM |  - Reinstated REM comments
REM |  - Added additional comments to explain code
REM |  - Rewrote "Get date info" to be more efficient 
REM | ----------------

REM | ===============================
REM | PREPARE ENVIRONMENT FOR SCRIPT
REM | ===============================

REM | Set location of batch file as current working directory
REM | NB: Breakdown of %~dp0:
REM |     % = start variable
REM |     ~ = remove surrounding quotes
REM |     0 = filepath of script
REM |     d = Expand 0 to drive letter only
REM |     p = expand 0 to path only
REM |     Therefore %~dp0 = 
REM |        Get current filepath of script (drive letter and path only)
REM |        No quote marks.
pushd "%~dp0"

REM | Clear screen.
cls

REM | Get date info in ISO 8601 standard date format (yyyy-mm-dd)
REM | NB: The SET function below works as follows:
REM |     VARIABLENAME:~STARTPOSITION,NUMBEROFCHARACTERS
REM |     Therefore in the string "20190327082654.880000+660"
REM |     ~0,4 translates to 2019
REM | NB: Carat (Escape character "^") needed to ensure pipe is processed as part of WMIC command instead of as part of the "for" loop
for /f %%a in ('WMIC OS GET LocalDateTime ^| find "."') do set DTS=%%a
set LOGDATE=%DTS:~0,4%-%DTS:~4,2%-%DTS:~6,2%
set LOGTIME=%DTS:~8,2%:%DTS:~10,2%:%DTS:~12,2%

REM | Logfile
REM | - Set log directory
set LOGPATH=%SYSTEMDRIVE%\Logs
REM | NB: %0 = Full file path of script
REM |     %~n0% = Script file name, no file extension
REM |     %~n0~x0 = Script file name, with file extension
REM | - Set log file name
REM |   - Include log path to ensure it is saved in the correct location.
set LOGFILE=

REM | Set display colours
color 1F

REM | Set location and system paths
setLocal EnableDelayedExpansion
if exist "%Windir%\Sysnative\sppsvc.exe" set SysPath=%Windir%\Sysnative
if exist "%Windir%\System32\sppsvc.exe"  set SysPath=%Windir%\System32

REM | ======
REM | TASKS
REM | ======

REM | Echo time and date
echo %YYYY%-%MM%-%DD% at %HH%:%NN%
echo.

::Echo Windows activation status
echo Windows Status:
echo ===============
ver
cscript //nologo %SysPath%\slmgr.vbs /dli
cscript //nologo %SysPath%\slmgr.vbs /xpr

REM | Echo Office 2016 activation status
echo.
echo.
echo Office 2016 Status:
echo ===================
set office=
set installed=0
FOR /F "tokens=2*" %%a IN ('reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Office\16.0\Common\InstallRoot" /v "Path" 2^&gt;nul') do (SET office=%%b)
if exist "%office%\OSPP.VBS" (
 set installed=1
 cd /d "%office%"
 cscript //nologo ospp.vbs /dstatus
 cd /d %~dp0
)
set office=
FOR /F "tokens=2*" %%a IN ('reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Office\16.0\Common\InstallRoot" /v "Path" 2^&gt;nul') do (SET office=%%b)
if exist "%office%\OSPP.VBS" (
 set installed=1
 cd /d "%office%"
 cscript //nologo ospp.vbs /dstatus
 cd /d %~dp0
)
if %installed%==1 goto end2016
if exist "C:\Program Files\Microsoft Office\Office16\OSPP.VBS" (
 set installed=1
 cd /d "C:\Program Files\Microsoft Office\Office16"
 cscript //nologo ospp.vbs /dstatus
 cd /d %~dp0
)
if exist "C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS" (
 set installed=1
 cd /d "C:\Program Files (x86)\Microsoft Office\Office16"
 cscript //nologo ospp.vbs /dstatus
 cd /d %~dp0
)
:end2016
if %installed%==0 echo Not installed

echo.

REM | ============================
REM | CLEAR ENVIRONMENT and EXIT
REM | ============================

REM | Reset current working directory
popd

REM | Exit and return exit code to PDQ Deploy
exit /B %EXIT_CODE%</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Stock0600</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Microsoft Licence Status</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>Write-Host 'Office 2016/2019 (32-bit) on a 32-bit version of Windows :'
cscript "C:\Program Files\Microsoft Office\Office16\OSPP.VBS" /dstatus

Write-Host 'Office 2016/2019 (32-bit) on a 64-bit version of Windows :'
cscript "C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS" /dstatus

Write-Host 'Office 2016/2019 (64-bit) on a 64-bit version of Windows :'
cscript "C:\Program Files\Microsoft Office\Office16\OSPP.VBS" /dstatus

Write-Host 'Office 2013 (32-bit) on a 32-bit version of Windows :'
cscript "C:\Program Files\Microsoft Office\Office15\OSPP.VBS" /dstatus
 
Write-Host 'Office 2013 (32-bit) on a 64-bit version of Windows :'
cscript "C:\Program Files (x86)\Microsoft Office\Office15\OSPP.VBS" /dstatus

Write-Host 'Office 2013 (64-bit) on a 64-bit version of Windows :'
cscript "C:\Program Files\Microsoft Office\Office15\OSPP.VBS" /dstatus

Write-Host 'Office 2010 (32-bit) on a 32-bit version of Windows :'
cscript "C:\Program Files\Microsoft Office\Office14\OSPP.VBS" /dstatus

Write-Host 'Office 2010 (32-bit) on a 64-bit version of Windows :'
cscript "C:\Program Files (x86)\Microsoft Office\Office14\OSPP.VBS" /dstatus

Write-Host 'Office 2010 (64-bit) on a 64-bit version of Windows :' -ForegroundColor Cyan
cscript "C:\Program Files\Microsoft Office\Office14\OSPP.VBS" /dstatus</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Office Licence Key/Status</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#store the license info into an array
$license = cscript 'C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS' /dstatus
#license name from /dstatus
$o365 = "Office16O365ProPlusR_Subscription1 edition"
#loop till the end of the array searching for the $o365 string 
for ($i = 0; $i -lt $license.Length; $i++) {
    if ($license[$i] -match $o365) {
        $i += 7
        #jumping seven lines to get to the product key line in the array
        $keyline = $license[$i]
        #extra step
        $prodkey = $keyline.substring($keyline.length – 5, 5)
        #getting the last 5 characters of the line (prodkey)
    } 
}
#removing the key from the workstation 
#cscript 'C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS' /unpkey:$prodkey</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Reset Office 365 Key on Client</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (1)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Checks</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$ScriptBlock = {    
    Get-ComputerRestorePoint -OutVariable RestorePoints
 
    if(-not($RestorePoints)){
        
        $env:COMPUTERNAME
 
        Enable-ComputerRestore -Drive C: -Verbose
    }
}
 
Invoke-Command -ScriptBlock $ScriptBlock</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check &amp; Active Points de Restauration</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Check des Certificats :
Write-Host "Liste Location :" -ForegroundColor Cyan
Get-ChildItem cert:*
Write-Host "LocalMachine :" -ForegroundColor Cyan
Get-ChildItem cert:LocalMachine | Select Name
Write-Host "CurrentUser :" -ForegroundColor Cyan
Get-ChildItem cert:CurrentUser | Select Name


#Pour les supprimer :

#Get-ChildItem cert:CurrentUser |
#Where-Object { $_.Subject -like ‘CN=*AncienCertificat*’ } |
#ForEach-Object {
#$store = Get-Item $_.PSParentPath
#$store.Open(‘ReadWrite’)
#$store.Remove($_)
#$store.Close()
#}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Computer's Certificats</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$disk = Get-Disk
$disk.FriendlyName

foreach($disk in Get-Disk)
{

if($disk.HealthStatus -eq 'Healthy')
    {
        Write-Host "Le status du disque "$Disk.FriendlyName" est"$disk.HealthStatus":)" -ForegroundColor Green

        }
        else {
        Write-Host "Le status du disque "$Disk.FriendlyName" est"$disk.HealthStatus":(" -ForegroundColor Red
        }
}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0200</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Disks Health Status (Win10)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>for ($i=0;$i -lt 7;$i++) {
$counters = Get-Counter -Counter '\disque physique(_total)\pourcentage du temps disque' #-ComputerName Alex
$properties = @(
 
@{n='Server';e={$_.Path.Split('\')[2]}},
 
@{n='Counter';e={$_.Path.Split('\')[-1]}},
 
@{n='Value';e={[math]::Round($_.CookedValue)}}
 
)
 
$counters.CounterSamples | Select-Object -Property $properties
 
sleep 1
 
}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0200</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Disk Usage %</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>$DriveSize = (Get-WmiObject Win32_LogicalDisk -filter "DriveType=3" |Select-Object -ExpandProperty size)/1GB
$AvailableSpace = (Get-WmiObject Win32_LogicalDisk -filter "DriveType=3" |Select-Object -ExpandProperty FreeSpace)/1GB
$DriveLetter = Get-WmiObject Win32_LogicalDisk -filter "DriveType=3" |Select-Object -ExpandProperty DeviceID

$DriveSizeStripped = "{0:F0}" -f $DriveSize
$AvailableSpaceStripped = "{0:F0}" -f $AvailableSpace
$PercentAvailable = "{0:P0}" -f ($AvailableSpace/$DriveSize)
$percent = ($used)/($disk.size)
$percent = "{0:P0}" -f $percent

Write-Host "Drive Letter: $DriveLetter"
Write-host "Disque de $DriveSizeStripped`GB"
Write-host "Espace disque libre : $AvailableSpaceStripped`GB"
Write-Host "Pourcentage utilisé : $percent"
Write-host "Pourcentage libre   : $PercentAvailable"


if ($PercentAvailable -lt 20) {Write-Host -ForegroundColor Red "Pas assez d'espace disque !"}
else {Write-Host -ForegroundColor Green "Il y a assez d'espace disque, OK !"}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0200</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Disk Espace</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Check dossier Menu Démarrer, check des programmes additionnels du menu démarrer

$dir = "$env:USERPROFILE\appdata\Roaming\Microsoft\Windows\Start Menu\Programs"
Get-ChildItem $dir -recurse</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Dossier Menu Démarrer</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$stuff = Get-WmiObject Win32_Share | Select-Object -Property AllowMaximum, Caption, Name, Path
Write-Host "Il y a" $stuff.Count -NoNewline
Write-Host " dossiers partages sur le poste" $env:computername -NoNewline
Write-Host " :"
$stuff #| Format-List</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Dossiers Partagés</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Commande pour trouver les fichiers .xpi des extensions Firefox
Get-ChildItem "C:\Program Files (x86)\Mozilla Firefox\browser\extensions" | Select-Object -Property Name,LastWriteTime, Length</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Firefox Extension (.xpi)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LoggedOnUser</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>&lt;#
@echo off
rem :: ============================= CH Avignon ::::::::::::==============================================================
rem :: ============================= Auteur : Alex =======================================================================
rem ::              Détection des Onglets principaux (onglet au premier plan) dans les navigateurs
rem ::              'Logged On User' dans PDQ
@echo off
#&gt;

#Pour Firefox
if($a = Get-Process Firefox*)
{Write-Host 'Onglet principal dans Firefox           :'$a.MainWindowTitle}
else{Write-Host "Pas de fenetre Firefox d'ouverte !"}

#Pour Google Chrome
if($b = Get-Process Chrome*)
{Write-Host 'Onglet principal dans Google Chrome     :'$b.MainWindowTitle}
else{Write-Host "Pas de fenetre Google Chrome d'ouverte !"}

#Pour Internet Explorer
if($c = Get-Process IExplore*)
{Write-Host 'Onglet principal dans Internet Explorer :'$c.MainWindowTitle}
else{Write-Host "Pas de fenetre Internet Explorer d'ouverte !"}


&lt;#
@echo off

#Surveillance Live:
while ($true) {

Get-Process iexplore |
select -expandproperty MainWindowTitle

Start-Sleep -Seconds 5
}

@echo off
#&gt;</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0850</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Firefox MainWindowTitle - LOGGED ON USER</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>#PDQ Inventory - Group Policy Report
import-module grouppolicy

#hide errors - disable this if you have issues and need to see errors
$ErrorActionPreference = "SilentlyContinue"

#sets the computer name - $(Computer:TARGETHOSTNAME) is the pdq variable for the target hostname
$computer = "$(Computer:TARGETHOSTNAME)"

#path for the temp file
$filepath = "%temp%\grouppolicy_" + $computer + "_temp.html"

#get the logged in user
$user = get-wmiobject -computername $computer -class win32_computersystem | select -expand username

#on-screen text for the user/computer report is being made for
if($user -ne $null -and $computer -ne $null){write-host "Retrieving Policy Report for $user on $computer..."}
if($user -eq $null -and $computer -ne $null){write-host "Retrieving Policy Report for $computer..."}

#try to run the report, if an error occurs display a message
try {get-gpresultantsetofpolicy -computer $computer -reporttype html -path $filepath -user $user | out-null}
catch {msg * "An error occured retrieving the policy report."}

#open the temp file (report file) and once the report is closed, delete the file.
start-process $filepath -wait
remove-item $filepath</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Group Policy Report GPO</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>$ProcessList = Get-WmiObject -ComputerName $(Computer:TARGETHOSTNAME) win32_process -Filter "Name = 'explorer.exe'"
$users = @()
ForEach ($process in $ProcessList) {
  $users += ($process.GetOwner()).User
}

Foreach($user in $users){
IF((Get-ADUser -Properties "LockedOut" -Identity $user).lockedout -eq $true){
Unlock-ADAccount -Identity $user
Echo "Le compte $users est bloque !"
}Else{
Echo "Le compte $users n'est pas bloque."
}
}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0510</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check if ADUser is Locked</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>Function Get-BiosType {

&lt;#
.Synopsis
   Determines underlying firmware (BIOS) type and returns an integer indicating UEFI, Legacy BIOS or Unknown.
   Supported on Windows 8/Server 2012 or later
.DESCRIPTION
   This function uses a complied Win32 API call to determine the underlying system firmware type.
.EXAMPLE
   If (Get-BiosType -eq 1) { # System is running UEFI firmware... }
.EXAMPLE
    Switch (Get-BiosType) {
        1       {"Legacy BIOS"}
        2       {"UEFI"}
        Default {"Unknown"}
    }
.OUTPUTS
   Integer indicating firmware type (1 = Legacy BIOS, 2 = UEFI, Other = Unknown)
.FUNCTIONALITY
   Determines underlying system firmware type
#&gt;

[OutputType([UInt32])]
Param()

Add-Type -Language CSharp -TypeDefinition @'

    using System;
    using System.Runtime.InteropServices;

    public class FirmwareType
    {
        [DllImport("kernel32.dll")]
        static extern bool GetFirmwareType(ref uint FirmwareType);

        public static uint GetFirmwareType()
        {
            uint firmwaretype = 0;
            if (GetFirmwareType(ref firmwaretype))
                return firmwaretype;
            else
                return 0;   // API call failed, just return 'unknown'
        }
    }
'@


    [FirmwareType]::GetFirmwareType()
}


Switch (Get-BiosType) {
        1       {"Legacy BIOS"}
        2       {"UEFI"}
        Default {"Unknown"}
    }</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0830</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check if BIOS ou EUFI</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$connected = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]"{DCB00C01-570F-4A9B-8D69-199FDBA5723B}")).IsConnectedToInternet

if ($Connected -eq "True") {
     Write-Host "vous etes connectes a internet"
}
else{
     Write-Host "vous n etes pas connectes a internet"
}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0830</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check if Connected to Internet</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$Device = $null
$Device = Get-WmiObject Win32_PNPEntity | Where-Object{$_.ConfigManagerErrorcode -ne 0}
if($Device -eq $null) {
Write-Host "Pas de peripherique manquant !"
}
else {   

Write-Host "Nom du peripherique manquant:    " -NoNewline
Write-Host $Device.Name -ForegroundColor Cyan

Write-Host "Compatible ID:       " -NoNewline
Write-Host $Device.CompatibleID -ForegroundColor Cyan
}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0830</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check if Missing Drivers</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$Is_Laptop_Plugged = (Get-WmiObject -Class BatteryStatus -Namespace root\wmi).PowerOnline 

if ($Is_Laptop_Plugged -eq $true) {
Write-Output "L'ordinateur fonctionne sur le secteur"
}

else {
Write-Error "L'ordinateur fonctionne sur batterie"
}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock1040</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check if Laptop Plugged</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>"Clavier Branche ? " +  [bool](@(Get-WmiObject win32_Keyboard | Where-Object { $_.Description -match "Périphérique d’entrée USB"}).Count -gt 0)</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0700</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check if Clavier Branché ? - TODO</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>"Souris Branchee ? " +  [bool](@(Get-WmiObject Win32_PointingDevice | Where-Object { $_.Description -match "Périphérique d’entrée USB"}).Count -gt 0)</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0700</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check if Souris branchée ? - TODO</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:00:20</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>Get-WmiObject win32_printer| select Name, Sharename, SystemName</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Local Printers</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$stuff = Get-WmiObject Win32_SystemUsers | Select-Object -Property PartComponent
Write-Host "Il y a" $stuff.Count -NoNewline
Write-Host " utilisateurs locaux sur le poste" $env:computername -NoNewline
Write-Host " :"
$stuff #| Format-List</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Local Users</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$Count = (gci c:\users| where {$_.PsIscontainer}).count


Write-Host "$Count"


$computer = $env:Computername

$customfieldname = "Nb Dossiers Users Local"
$Customfieldtype = "String"    # Boolean, String, Integer, Date, or DateTime

 $computerlist = @("ComputerName,$customfieldname")

 $computer | ForEach-Object {

$computerlist += "$_,$Count"

}


$tempfile = New-TemporaryFile
$computerlist | out-file $tempfile

pdqinventory createcustomfield -name $customfieldname -type $customfieldtype
pdqinventory importcustomfields -filename $tempfile -computercolumn "ComputerName" -customfields "$Customfieldname=$customfieldname" -allowoverwrite</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Nb Dossiers Users Local</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$UserProperty = @{n="user";e={(New-Object System.Security.Principal.SecurityIdentifier $_.ReplacementStrings[1]).Translate([System.Security.Principal.NTAccount])}}
$TypeProperty = @{n="Action";e={if($_.EventID -eq 7001) {"Logon"} else {"Logoff"}}}
$TimeProperty = @{n="Time";e={$_.TimeGenerated}}
Get-EventLog System -Source Microsoft-Windows-Winlogon | select $UserProperty,$TypeProperty,$TimeProperty</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0890</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Logon History</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>Get-PrinterDriver</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check OS Printer's Drivers</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LoggedOnUser</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$Shortcuts = Get-ChildItem -Recurse $env:USERPROFILE\desktop\ -Include *.lnk

$Shell = New-Object -ComObject WScript.Shell
foreach ($Shortcut in $Shortcuts)
{
 $Properties = @{
 ShortcutName = $Shortcut.Name
 Path = $Shortcut.FullName
 ShortcutDirectory = $Shortcut.DirectoryName
 Target = $Shell.CreateShortcut($Shortcut).targetpath
 }
 New-Object PSObject -Property $Properties
}
    
    $retour = Foreach ($Shortcut in $Shortcuts)
    {Test-Path $Properties.Target}
    
    If ($retour -eq $false){
    Write-Output "Raccourcis invalides ! :("
    
    }Else{
    Write-Output "Pas de mauvais raccourcis trouves ! :)"

}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0895</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Raccourcis Cassés - Logged on User</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>function get-WmiMemoryFormFactor {
param ([uint16] $char)

If ($char -ge 0 -and  $char  -le 22) {

switch ($char) {
0     {"00-Unknown"}
1     {"01-Other"}
2     {"02-SiP"}
3     {"03-DIP"}
4     {"04-ZIP"}
5     {"05-SOJ"}
6     {"06-Proprietary"}
7     {"07-SIMM"}
8     {"08-DIMM"}
9     {"09-TSOPO"}
10     {"10-PGA"}
11     {"11-RIM"}
12     {"12-SODIMM"}
13     {"13-SRIMM"}
14     {"14-SMD"}
15     {"15-SSMP"}
16     {"16-QFP"}
17     {"17-TQFP"}
18     {"18-SOIC"}
19     {"19-LCC"}
20     {"20-PLCC"}
21     {"21-FPGA"}
22     {"22-LGA"}
}
}

else {"{0} - undefined value" -f $char
}

Return
}

# Helper function to return memory Interleave  Position

function get-WmiInterleavePosition {
param ([uint32] $char)

If ($char -ge 0 -and  $char -le 2) {

switch ($char) {
0     {"00-Non-Interleaved"}
1     {"01-First Position"}
2     {"02-Second Position"}
}
}

else {"{0} - undefined value" -f $char
}

Return
}


# Helper function to return Memory Tupe
function get-WmiMemoryType {
param ([uint16] $char)

If ($char -ge 0 -and  $char  -le 30) {

switch ($char) {
1     {"01-Other"}
2     {"02-Unknown"}
3     {"03-DRAM"}
4     {"04-EDRAM"}
5     {"05-VRAM"}
6     {"06-SRAM"}
7     {"07-RAM"}
8     {"08-ROM"}
9     {"09-FLASH"}
10     {"10-EEPROM"}
11     {"11-FEPROM"}
12     {"12-EPROM"}
13     {"13-CDRAM"}
14     {"14-3DRAM"}
15     {"15-SDRAM"}
16     {"16-SGRAM"}
17     {"17-RDRAM"}
18     {"18-DDR"}
19     {"19-DDR2"}
20     {"20-DDR2FB-DIMM"}
24     {"24-DDR3"}
25     {"25-FBD2"}
26     {"26-DDR4"}
27     {"27-LPDDR"}
28     {"28-LPDDR2"}
29     {"29-LPDDR3"}
30     {"30-LPDDR4"}
}

}

else {"{0} - undefined value" -f $char
}

Return
}


# Get the object
$memory = Get-WMIObject Win32_PhysicalMemory

#  Format and Print
"System has {0} memory sticks:" -f $memory.count

Foreach ($stick in $memory) {

# Do some conversions
$cap=$stick.capacity/1mb
$ff=get-WmiMemoryFormFactor($stick.FormFactor)
$ilp=get-WmiInterleavePosition($stick.InterleavePosition)
$smbiosmt=get-WMIMemoryType($stick.SMBIOSMemoryType)

# print details of each stick
"BankLabel            {0}"  -f $stick.banklabel
"Capacity (MB)        {0}"  -f $cap
#"Caption              {0}"  -f $stick.Caption
#"CreationClassName    {0}"  -f $stick.creationclassname
#"DataWidth            {0}"  -f $stick.DataWidth
"Description          {0}"  -f $stick.Description
#"DeviceLocator        {0}"  -f $stick.DeviceLocator
"FormFactor           {0}"  -f $ff
#"HotSwappable         {0}"  -f $stick.HotSwappable
#"InstallDate          {0}"  -f $stick.InstallDate
#"InterleaveDataDepth  {0}"  -f $stick.InterleaveDataDepth
#"InterleavePosition   {0}"  -f $ilp
"Manufacturer         {0}"  -f $stick.Manufacturer
"MemoryType           {0}"  -f $smbiosmt
#"Model                {0}"  -f $stick.Model
#"Name                 {0}"  -f $stick.Name
#"OtherIdentifyingInfo {0}"  -f $stick.OtherIdentifyingInfo
#"PartNumber           {0}"  -f $stick.PartNumber
#"PositionInRow        {0}"  -f $stick.PositionInRow
#"PoweredOn            {0}"  -f $stick.PoweredOn
#"Removable            {0}"  -f $stick.Removable
#"Replaceable          {0}"  -f $stick.Replaceable
#"SerialNumber         {0}"  -f $stick.SerialNumber
#"SKU                  {0}"  -f $stick.SKU 
"Speed                {0}"  -f $stick.Speed 
#"Status               {0}"  -f $stick.Status
#"Tag                  {0}"  -f $stick.Tag
#"TotalWidth           {0}"  -f $stick.TotalWidth 
#"TypeDetail           {0}"  -f $stick.TypeDetail
#"Version              {0}"  -f $stick.Version
""
}
"-----"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check RAM Infos</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>Test-ComputerSecureChannel -Server $(Computer:TARGETHOSTNAME)</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0055</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Relation d'Approbation</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>$Username = 'ADCHA\AGasparoux'
$encrypted = Get-Content -Path '\\srv-nas-info\adminarsenal$\Repository\Scripts\CheckDomain\Creds\Required.txt'
$key = (1..16)
$Password = $encrypted | ConvertTo-SecureString -Key $key
$Credentials = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $Username, $Password

Test-ComputerSecureChannel -Credential $Credentials -Repair</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0055</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Fix Relation d'Approbation - A TESTER</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$stuff = Get-WmiObject Win32_ShadowCopy | Select-Object -Property DeviceObject, InstallDate
Write-Host "Il y a" $stuff.Count -NoNewline
Write-Host " ShadowCopy sur le poste" $env:computername -NoNewline
Write-Host " :"
$stuff #| Format-List</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check ShadowCopy</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>$stuff = Get-WmiObject Win32_StartupCommand | Select-Object -Property Caption, Command, Location
Write-Host "Il y a" $stuff.Count -NoNewline
Write-Host " programmes se lancant au démarrage sur le poste" $env:computername -NoNewline
Write-Host " :"
$stuff #| Format-List</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Startup</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>Get-WmiObject -computer $(Computer:TARGET) Win32_Service -Filter "Name='Spooler'" | ft systemname, name, state</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Spooler State</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LoggedOnUser</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine># Get the cumulative size of all user profiles on the system in GB

$Sum = [math]::Round(
  (
    (
      (
        Get-ChildItem -Path "\\home.adcha.local\USERS$\$env:username" |
        ForEach-Object {
          Write-Host "Analyse du dossier : $($_.FullName)" -ForegroundColor Green ;
          Get-ChildItem -Path $_.FullName -Recurse -File -ErrorAction SilentlyContinue } | Measure-Object -Property Length -Sum).Sum)/1MB
    )
)
write-Host "Nombre de fichiers contenus dans le dossier utilisateur de $env:username : " -NoNewline -ForegroundColor Cyan
@(Dir \\home.adcha.local\USERS$\$env:username).Count 
write-Host "Taille totale des donnees contenus dans le dossier utilisateur partage de $env:username : " -ForegroundColor Cyan -NoNewline
Write-Host "$Sum Mb"
Write-Host "Chemin analyse : " -ForegroundColor Cyan -NoNewline
Write-Host "\\home.adcha.local\USERS$\$env:username"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check User Profile Size - Logged on User</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>netstat.exe -n</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Icon-CommandStep</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check NetStat.exe -n</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (1)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Check AD Logs</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>$dte = (Get-Date).adddays(-15)
Write-Host "Changements apres $dte :"
Get-ADObject -Filter 'whenchanged -gt $dte' | Group-Object objectclass</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0890</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Report All Changes depuis 15 jours</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>$dte = (Get-Date).adddays(-15)
Write-Host "Changements apres $dte :"
$stuff = Get-ADComputer -Filter 'whencreated -gt $dte' -Properties * |  ft CN,LastKnownParent,whenChanged -AutoSize
$stuff</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0890</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Report Computers Créés depuis 15 jours</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>\\srv-nas-info\adminarsenal$\repository\Scripts\AD\GetADLastLogonMachines.ps1 -LastLogonOnly -OuOnly -MaxEvent 1500 | Where-Object {$_.User -like "*" -and $_.Workstation -notlike "sftp","exchange1","exchange2"} | Select -Property 'Authenticated DC','LoggedOn Time',User,Workstation | Format-Table * -AutoSize</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Last Logon &amp; Machines par User</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>Import-Module ActiveDirectory  
$Domain = "adcha.local"  
$DaysInactive = 300 
$time = (Get-Date).Adddays(-($DaysInactive)) 

Get-ADComputer -Filter {LastLogonTimeStamp -lt $time} -Properties LastLogonTimeStamp | Select-Object -Property DNSHostName</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check Postes inactifs depuis xxx jours</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>Get-ADComputer -Filter "name -like '*'" -Properties operatingSystem | group -Property operatingSystem | Select Name,Count</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Check all computers by OS</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (3)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Check Online Last Versions</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>&lt;#
 ===========================================================================
  Created with:  Visual Studio Code 1.32.3/PS ISE 17763
  Revision:      v2
  Last Modified: 27 March 2019
  Created by:    Jay Harper (github.com/thecatdidit/powershellusefulscripts)
  Organizaiton:  Happy Days Are Here Again
  Filename:      Get-OnlineVer7Zip.ps1
 ===========================================================================
 .CHANGELOG
 [2019.03.27.01]
 Script creation
 .SYNOPSIS
        Queries the 7Zip webside for the current version of
        the app and returns the version, date updated, and
        download URLs if available.
 .DESCRIPTION
     This function retrieves the latest data associated with 7Zip
        Invoke-WebRequest queries the site to obtain app release date, version and 
        download URLs. This includes x86 and x64.
        It then outputs the information as a
        PSObject to the Host
        App Site: https://www.7-zip.org/
 .EXAMPLE
        PS C:\&gt; Get-OnlineVer7Zip
        Software_Name    : 7Zip
        Software_URL     : https://www.7-zip.org/download.html
        Online_Version   : 19.00
        Online_Date      : 2019-02-21
        Download_URL_x64 : https://www.7-zip.org/a/7z1900-x64.msi
        Download_URL_x86 : https://www.7-zip.org/a/7z1900.msi
    
        PS C:\&gt; Get-OnlineVer7Zip -Quiet
        19.00
 
  .INPUTS
        -Quiet
            Use of this parameter will output just the current version of
            Flash Player instead of the entire object. It will always be the
            last parameter
     
 .OUTPUTS
            An object containing the following:
            Software Name: Name of the software
            Software URL: The URL info was sourced from
            Online Version: The current version found
            Online Date: The date the version was updated
            Download URL x64: Direct download link for the x64 version
            Download URL x86: Direct download link for the x86 version
    
            If -Quiet is specified then just the value of 'Online Version'
            will be displayed.
 .NOTES
            Resources/Credits:
            https://github.com/itsontheb
#&gt;

function Get-OnlineVer7Zip {
    [cmdletbinding()]
    param (
        [Parameter(Mandatory = $false, 
            Position = 0)]
        [switch]
        $Quiet
    )

    begin {
        # Initial Variables
        $SoftwareName = '7Zip'
        $URI = 'https://www.7-zip.org/download.html'
            
        $hashtable = [ordered]@{
            'Software_Name'    = $softwareName
            'Software_URL'     = $uri
            'Online_Version'   = 'UNKNOWN' 
            'Online_Date'      = 'UNKNOWN'
            'Download_URL_x86' = 'UNKNOWN'
            'Download_URL_x64' = 'UNKNOWN'
        }
    
        $swObject = New-Object -TypeName PSObject -Property $hashtable
    }


    Process {
        # Get the Version &amp; Release Date
        try {
            Write-Verbose -Message "Attempting to pull info from the below URL: `n $URI"
            $uri = 'https://www.7-zip.org/download.html'
            $7ZipURL = (Invoke-WebRequest -Uri $uri | Select-Object -ExpandProperty Content)
            $7ZIPURL -match "&lt;P&gt;&lt;B&gt;Download 7-Zip (?&lt;version&gt;.*) \((?&lt;date&gt;.*)\) f" | Out-Null
            $7ZipVersion = ($matches['version'])
            $7ZipDate = ($matches['date'])
            
            $swObject.Online_Version = $7ZipVersion
            $swObject.Online_Date = $7ZipDate

        }
        catch {
            Write-Verbose -Message "Error accessing the below URL: `n $URI"
            $message = $("Line {0} : {1}" -f $_.InvocationInfo.ScriptLineNumber, $_.exception.message)
            $swObject | Add-Member -MemberType NoteProperty -Name 'ERROR' -Value $message
        }
        finally {
          

            # Get the Download URLs
            if ($swObject.Online_Version -ne 'UNKNOWN') {
       
                $7ZipDownloadx64 = "https://www.7-zip.org/a/7z" + $7ZipVersion.replace(".", "") + "-x64.msi"
                $7ZipDownloadx86 = "https://www.7-zip.org/a/7z" + $7ZipVersion.replace(".", "") + ".msi"
            
            
                $swObject.Download_URL_x86 = $7ZipDownloadx86
                $swObject.Download_URL_x64 = $7ZipDownloadx64
            }
        }
    }
    End {
        # Output to Host
        if ($Quiet) {
            Write-Verbose -Message '$Quiet was specified. Returning just the version'
            Return $swObject.Online_Version
        }
        else {
            Return $swobject
        }
    }
}  # END Function Get-OnlineVer7Zip

Get-OnlineVer7Zip</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get-OnlineVer7Zip</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>&lt;# 
 .NOTES
 ===========================================================================
  Created with:  PowerShell ISE (Win10 17763)
  Revision: v5
  Last Modified: 27 Mar 2019
  Created by:    Jay Harper (github.com/thecatdidit/powershellusefulscripts)
  Organizaiton:  Happy Days Are Here Again
  Filename:      Get-OnlineVerAdobeReader.ps1
 ===========================================================================
 .CHANGELOG
 [2019.27.03.1230]
 Script creation
 .SYNOPSIS
        Queries the Adobe Website for the current version of
        Adobe Acrobat Reader DC. The script returns the version, date updated, and
        download URLs if available.
 .DESCRIPTION
        This function retrieves the latest data associated with Adobe Reader.
        Utilizes Invoke-WebRequest to query Adobe Reader's release notes pagean
        and pulls out the Version, Update Date and Download URLs for
        the app (x64 only) It then outputs the information as a
        PSObject to the Host.
 .EXAMPLE
        PS C:\&gt; Get-OnlineVerAdobeReader.ps1
        Software_Name    : Adobe Acrobat Reader DC
        Software_URL     : https://helpx.adobe.com/acrobat/release-note/release-notes-acrobat-reader.html
        Online_Version   : 19.010.20098
        Online_Date      : Feb 21,2019
        Download_URL_x64 : http://ardownload.adobe.com/pub/adobe/reader/win/AcrobatDC/1901020098/AcrodrDCUpd1901020098.msp
        PS C:\&gt; Get-OnlineVerAdobeReader.ps1 -Quiet
        19.010.20098
 .INPUTS
        -Quiet
         Use of this parameter will output just the current version of
         Adobe Reader instead of the entire object. It will always be the
         last parameter.
 .OUTPUTS
        An object containing the following:
        Software Name: Name of the software
        Software URL: The URL info was sourced from
        Online Version: The current version found
        Online Date: The date the version was updated
    
        If -Quiet is specified then just the value of 'Online Version'
        will be displayed.
 
 .NOTES
        Resources/Credits:
        https://github.com/itsontheb
#&gt;

function Get-OnlineVerAdobeReader {
    [cmdletbinding()]
    param (
        [Parameter(Mandatory = $false, 
            Position = 0)]
        [switch]
        $Quiet
    )

    begin {
        # Initial Variables
        $softwareName = 'Adobe Acrobat Reader DC'
        $uri = 'https://helpx.adobe.com/acrobat/release-note/release-notes-acrobat-reader.html'
            
        $hashtable = [ordered]@{
            'Software_Name'    = $softwareName
            'Software_URL'     = $uri
            'Online_Version'   = 'UNKNOWN' 
            'Online_Date'      = 'UNKNOWN'
            'Download_URL_x64' = 'UNKNOWN'
        }
    
        $swObject = New-Object -TypeName PSObject -Property $hashtable
    }
    Process {
        # Get the Version &amp; Release Date
        try {
            $VersionRegex = "\d+(\.\d+)+"
            $html = Invoke-WebRequest -UseBasicParsing -Uri "$uri"
            $DC_Versions = $html.Links | Where-Object outerHTML -Match "\($VersionRegex\)"
            $versionArray = @()
            foreach ($version in $DC_Versions) {
                $VersionNumber = [regex]::match($Version.outerHTML , "$VersionRegex").Value
                $versionArray += $VersionNumber
            }
            $adobeVersion = $versionArray[0]
        
            $site = (Invoke-WebRequest -Uri $uri | Select-Object -ExpandProperty Content)
            $site -match "&lt;td valign=""top""&gt;&lt;p&gt;&lt;strong&gt;Focus&lt;/strong&gt;&lt;/p&gt;`n&lt;/td&gt;`n&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;(?&lt;content&gt;.*)&lt;/td&gt;" | Out-Null
            $adobeDate = ($matches['content'])
      
            $urlData = $adobeVersion.Replace(".", "")
            $downloadURL = 'http://ardownload.adobe.com/pub/adobe/reader/win/AcrobatDC/' + $urlData + "/AcrodrDCUpd" + $urlData + ".msp"
        
            $swObject.Download_URL_x64 = $downloadURL
            $swObject.Online_Version = $adobeVersion
            $swObject.Online_Date = $adobeDate
        
        }
        catch {
            Write-Verbose -Message "Error accessing the below URL: `n $URI"
            $message = $("Line {0} : {1}" -f $_.InvocationInfo.ScriptLineNumber, $_.exception.message)
            $swObject | Add-Member -MemberType NoteProperty -Name 'ERROR' -Value $message
        }
        finally {
        }
    }
    End {
        # Output to Host
        if ($Quiet) {
            Write-Verbose -Message '$Quiet was specified. Returning just the version'
            Return $swObject.Online_Version
        }
        else {
            Return $swobject
        }
    }
}  # END Function Get-OnlineVerAdobeReader
Get-OnlineVerAdobeReader</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get-OnlineVerAdobeReader</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>&lt;#
 ===========================================================================
  Created with:  PowerShell ISE (Win10 18362/1903)
  Revision: 2019.08.13.01
  Last Modified: 13 August 2019
  Created by:    Jay Harper (github.com/thecatdidit/powershellusefulscripts)
  Organizaiton:  Happy Days Are Here Again
  Filename:      Get-OnlineVerFirefox.ps1
 ===========================================================================
 .CHANGELOG
 [2019.08.13.01]
 Updated content query of FF release notes to reflect HTML layout changes
 [2018.12.14.02]
 Cleaned up errant tabs and spaces that were acting screwy on GitHub.
 [2018.12.18.01]
 Updated script documentation with information on URL syntax, etc.
 .SYNOPSIS
        Queries Mozilla's Website for the current version of
        Firefox and returns the version, date updated, and
        download URLs if available.
 .DESCRIPTION
 This function retrieves the latest data associated with Mozilla Firefox
        Invoke-WebRequest queries the site to obtain app release date, version and 
        download URLs. This includes x86 and x64.
        It then outputs the information as a
        PSObject to the Host
        The version info for Firefox is obtained from a JSON file that Mozilla 
        maintains for browser builds (current, beta, etc.). Once the version
        number is obtained, it is used to find the date of release by
        parsing data from the Firefox release notes website. The date is
        extracted from this page as the JSON data tends to suffer from mistypes
        on occasion when new builds are released.
        The URLs for the release notes and direct download links are extrapolated
        by updating Firefox's URL syntax with the version number. The teplates:
        Release Notes: https://www.mozilla.org/en-us/firefox/ + &lt;VERSION&gt; + /releasenotes/
        Download URL: https://download-origin.cdn.mozilla.net/pub/firefox/releases/ + &lt;VERSION&gt; + /win64/en-US/Firefox%20Setup%20 + &lt;VERSION&gt;.exe
            
        Firefox 64.0 is the version at the time of documentation. Using that version, we would get
        Release Notes: https://www.mozilla.org/en-us/firefox/64.0/releasenotes/
        Download URL: https://download-origin.cdn.mozilla.net/pub/firefox/releases/64.0/win64/en-US/Firefox%20Stup%2064.0.exe
 .EXAMPLE
        PS C:\&gt; Get-OnlineVerFirefox.ps1
        Software_Name    : Mozilla Firefox
        Software_URL     : https://product-details.mozilla.org/1.0/firefox_versions.json
        Online_Version   : 61.0.2
        Online_Date      : 2018-08-08
        Download_URL_x64 : https://download-origin.cdn.mozilla.net/pub/firefox/releases/61.0.2/win64/en-US/Firefox%20Setup%2061.0.2.exe
        Download_URL_x86 : https://download-origin.cdn.mozilla.net/pub/firefox/releases/61.0.2/win32/en-US/Firefox%20Setup%2061.0.2.exe
    
        PS C:\&gt; Get-OnlineVerFirefox -Quiet
        61.0.2
 
  .INPUTS
        -Quiet
            Use of this parameter will output just the current version of
            Flash Player instead of the entire object. It will always be the
            last parameter
     
 .OUTPUTS
            An object containing the following:
            Software Name: Name of the software
            Software URL: The URL info was sourced from
            Online Version: The current version found
            Online Date: The date the version was updated
            Download URL x64: Direct download link for the x64 version
            Download URL x86: Direct download link for the x86 version
    
            If -Quiet is specified then just the value of 'Online Version'
            will be displayed
 .NOTES
            Resources/Credits:
            https://github.com/itsontheb
#&gt;

function Get-OnlineVerFirefox {

    [cmdletbinding()]
    param (
        [Parameter(Mandatory = $false, 
            Position = 0)]
        [switch]
        $Quiet
    )

    begin {
        # Initial Variables
        $SoftwareName = "Mozilla Firefox"
        $uri = 'https://product-details.mozilla.org/1.0/firefox_versions.json'
       
            
        $hashtable = [ordered]@{
            'Software_Name'    = $softwareName
            'Software_URL'     = 'UNKNOWN'
            'Online_Version'   = 'UNKNOWN' 
            'Online_Date'      = 'UNKNOWN'
            'Download_URL_x64' = 'UNKNOWN'
            'Download_URL_x86' = 'UNKNOWN'
           
        }
    
        $swObject = New-Object -TypeName PSObject -Property $hashtable
    }


    Process {
        # Get the Version &amp; Release Date
        try {
            Write-Verbose -Message "Attempting to pull info from the below URL: `n $URI"
            

            $uri = 'https://product-details.mozilla.org/1.0/firefox_versions.json'
            $FirefoxVersion = Invoke-WebRequest $uri -UseBasicParsing | ConvertFrom-Json | Select-Object -ExpandProperty LATEST_FIREFOX_vERSION
            $ffReleaseNotes = "https://www.mozilla.org/en-us/firefox/" + $firefoxversion + "/releasenotes/"
            (Invoke-WebRequest -Uri $ffReleaseNotes | Select-Object -ExpandProperty Content) -match "&lt;p class=""c-release-date""&gt;(?&lt;content&gt;.*)&lt;/p&gt;" | Out-Null
            $FirefoxDate = ($matches['content'])
            $FirefoxDownloadX64 = "https://download-origin.cdn.mozilla.net/pub/firefox/releases/" + $FirefoxVersion + "/win64/en-US/Firefox%20Setup%20" + $FirefoxVersion + ".exe"
            $FirefoxDownloadX86 = "https://download-origin.cdn.mozilla.net/pub/firefox/releases/" + $FirefoxVersion + "/win32/en-US/Firefox%20Setup%20" + $FirefoxVersion + ".exe"
        

            $swObject.Online_Version = $FirefoxVersion
            $swobject.Online_Date = $FirefoxDate
            $swobject.Software_URL = $ffReleaseNotes
         
        } 
        catch {
            Write-Verbose -Message "Error accessing the below URL: `n $URI"
            $message = $("Line {0} : {1}" -f $_.InvocationInfo.ScriptLineNumber, $_.exception.message)
            $swObject | Add-Member -MemberType NoteProperty -Name 'ERROR' -Value $message
        }
        finally {
          

            # Get the Download URLs
            if ($swObject.Online_Version -ne 'UNKNOWN') {
           
                $swobject.Download_URL_X64 = $FirefoxDownloadX64
                $swobject.Download_URL_X86 = $FirefoxDownloadX86
            }
        }
    }
    End {
        # Output to Host
        if ($Quiet) {
            Write-Verbose -Message '$Quiet was specified. Returning just the version'
            Return $swObject.Online_Version
        }
        else {
            Return $swobject
        }
    }
}  # END Function Get-OnlineVerFirefox
Get-OnlineVerFirefox</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get-OnlineVerFirefox</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>&lt;# 
    .NOTES
 ===========================================================================
  Created with:  PowerShell ISE (Win10 17134)
  Revision: v5
  Last Modified: 24 August 2018
  Created by:    Jay Harper (github.com/thecatdidit/powershellusefulscripts)
  Organizaiton:  Happy Days Are Here Again
  Filename:      Get-OnlineVerFlashPlayer.ps1
 ===========================================================================
    .SYNOPSIS
        Queries Adobe's Flash Player Website for the current version of
        the app and returns the version, date updated, and
        download URLs if available.
    .DESCRIPTION
 This function retrieves the latest data associated with Adobe Flash Player
        Invoke-WebRequest queries the site to obtain app release date, version and 
        download URLs. This includes NPAPI, PPAPI and ActiveX
        It then outputs the information as a
        PSObject to the Host.
    .DISCLAIMER
        At the moment, the release date of Flash Player is being obtained from FileHippo.
        Once I have a bit of spare time, I will try and change this to reflectuse of the 
 vendor site. Usage of this script may affect the terms of your Adobe Enterprise deployment agreement for Flash Player. 
 This script is provided AS-IS for the purposes of version tracking ONLY.
    .EXAMPLE
        PS C:\&gt; Get-OnlineVerFlashPlayer.ps1
        Software_Name        : Adobe Flash Player
        Software_URL         : https://fpdownload.macromedia.com/pub/flashplayer/masterversion/masterversion.xml
        Online_Version       : 30.0.0.154
        Online_Date          : August 21, 2018
        Download_URL_PPAPI   : https://fpdownload.macromedia.com/pub/flashplayer/pdc/30.0.0.154/install_flash_player_30_ppapi.msi
        Download_URL_NPAPI   : https://fpdownload.macromedia.com/pub/flashplayer/pdc/30.0.0.154/install_flash_player_30_plugin.msi
        Download_URL_ActiveX : https://fpdownload.macromedia.com/pub/flashplayer/pdc/30.0.0.154/install_flash_player_30_active_X.msi
        PS C:\&gt; Get-OnlineVerFlashPlayer -Quiet
        30.0.0.154
    
    .INPUTS
        -Quiet
            Use of this parameter will output just the current version of
            Flash Player instead of the entire object. It will always be the
            last parameter.
    .OUTPUTS
            An object containing the following:
            Software Name: Name of the software
            Software URL: The URL info was sourced from
            Online Version: The current version found
            Online Date: The date the version was updated
            Download URL PPAPI: Download URL for the PPAPI version
            Download URL NPAPI: Download URL for the NPAPI version
            Download URL ActiveX: Download URL for the ActiveX version
    
            If -Quiet is specified then just the value of 'Online Version'
            will be displayed.
    .NOTES
            Resources/Credits:
            https://github.com/itsontheb (for help with creation of the update PSObject)
#&gt;

#Allows TLS 1.2 for FileHippo HTTPS access
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

function Get-OnlineVerFlashPlayer {

    [cmdletbinding()]
    param (
        [Parameter(Mandatory = $false, 
            Position = 0)]
        [switch]
        $Quiet
    )

    begin {
        # Initial Variables
        $SoftwareName = "Adobe Flash Player"
        $uri = 'https://fpdownload.macromedia.com/pub/flashplayer/masterversion/masterversion.xml'
       
            
        $hashtable = [ordered]@{
            'Software_Name'        = $softwareName
            'Software_URL'         = $uri
            'Online_Version'       = 'UNKNOWN' 
            'Online_Date'          = 'UNKNOWN'
            'Download_URL_PPAPI'   = 'UNKNOWN'
            'Download_URL_NPAPI'   = 'UNKNOWN'
            'Download_URL_ActiveX' = 'UNKNOWN'
        }
    
        $swObject = New-Object -TypeName PSObject -Property $hashtable
    }


    Process {
        # Get the Version &amp; Release Date
        try {
            Write-Verbose -Message "Attempting to pull info from the below URL: `n $URI"
            

            $uri = 'https://fpdownload.macromedia.com/pub/flashplayer/masterversion/masterversion.xml'
            $xml_versions = New-Object XML
            $xml_versions.Load($uri)
            $FlashMajorVersion = ($xml_versions.version.release.NPAPI_win.version).Substring(0, 2)
            $FlashFullVersion = ($xml_versions.version.release.NPAPI_win.version).replace(",", ".")
            $FlashURLPrefix = "https://fpdownload.macromedia.com/pub/flashplayer/pdc/" + $FlashFullVersion
            $FlashDateURI = (Invoke-WebRequest -Uri https://filehippo.com/download_adobe-flash-player/tech -UseBasicParsing | Select-Object Content -ExpandProperty Content)
            $FlashDateURI -match "Date added:&lt;/span&gt; &lt;span class=""field-value""&gt;`r`n                                (?&lt;content&gt;.*)&lt;/span&gt;" | Out-Null
            $app1Date = ($matches['content'])
            $swObject.Online_Version = $FlashFullVersion
            $swobject.Online_Date = $app1Date
        
         
        } 
        catch {
            Write-Verbose -Message "Error accessing the below URL: `n $URI"
            $message = $("Line {0} : {1}" -f $_.InvocationInfo.ScriptLineNumber, $_.exception.message)
            $swObject | Add-Member -MemberType NoteProperty -Name 'ERROR' -Value $message
        }
        finally {
          

            # Get the Download URLs
            if ($swObject.Online_Version -ne 'UNKNOWN') {
           
            
                $FlashURLPPAPI = $FlashURLPrefix + "/install_flash_player_" + $FlashMajorVersion + "_ppapi.msi"
                $FlashURLActiveX = $FlashURLPRefix + "/install_flash_player_" + $FlashMajorVersion + "_active_X.msi"
                $FLashURLNPAPI = $FlashURLPRefix + "/install_flash_player_" + $FlashMajorVersion + "_plugin.msi"

                $swObject.DOWNLOAD_URL_PPAPI = $FlashURLPPAPI
                $swObject.DOWNLOAD_URL_NPAPI = $FlashURLNPAPI
                $swObject.DOWNLOAD_URL_ActiveX = $FlashURLActiveX
            }
        }
    }
    End {
        # Output to Host
        if ($Quiet) {
            Write-Verbose -Message '$Quiet was specified. Returning just the version'
            Return $swObject.Online_Version
        }
        else {
            Return $swobject
        }
    }
}  # END Function Get-OnlineVerFlashPlayer
Get-OnlineVerFlashPlayer</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get-OnlineVerFlashPlayer</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>&lt;#
.NOTES
 ===========================================================================
  Created with:  PowerShell ISE
  Revision: v6
  Last Modified: 24 August 2018
  Created by:    Jay Harper (github.com/thecatdidit/powershellusesfulscripts)
  Organizaiton:  Happy Days Are Here Again
  Filename:      Get-OnlineVerGoogleChrome.ps1
 ===========================================================================
.Synopsis
    Queries Google's Website for the current version of
    Chrome and returns the version, date uploaded and download URLs
.DESCRIPTION
    Utilizes Invoke-WebRequest to query Google Chrome's Dev Team Blog and
    pulls out the Version, Update Date and Download URLs for both
    x68 and x64 versions. It then outputs the information as a
    PSObject to the Host.
.EXAMPLE
        PS C:\&gt; Get-OnlineVerFlashPlayer.ps1
        Software_Name    : GoogleChrome
        Software_URL     : http://feeds.feedburner.com/GoogleChromeReleases
        Online_Version   : 68.0.3440.106
        Online_Date      : 2018-08-23
        Download_URL_x86 : https://dl.google.com/dl/chrome/install/googlechromestandaloneenterprise64.msi
        Download_URL_x64 : https://dl.google.com/dl/chrome/install/googlechromestandaloneenterprise.msi
 
 PS C:\&gt; Get-OnlineVeNotePadPlusPlus -Quiet
        68.0.3440.106
.INPUTS
    -Quiet
        Use of this parameter will output just the current version of
        Google Chrome instead of the entire object. It will always be the
        last parameter.
.OUTPUTS
        An object containing the following:
        Software Name: Name of the software
        Software URL: The URL info was sourced from
        Online Version: The current version found
        Online Date: The date the version was updated
        Download URL x86: Download URL for the win32 version
        Download URL x64: Download URL for the win64 version
.EXAMPLE
        Software_Name    : GoogleChrome
        Software_URL     : http://feeds.feedburner.com/GoogleChromeReleases
        Online_Version   : 68.0.3440.106
        Online_Date      : 2018-08-23
        Download_URL_x86 : https://dl.google.com/dl/chrome/install/googlechromestandaloneenterprise64.msi
        Download_URL_x64 : https://dl.google.com/dl/chrome/install/googlechromestandaloneenterprise.msi
    If -Quiet is specified then just the value of 'Online Version'
     will be displayed.
.NOTES
    Resources/Credits:
    https://github.com/itsontheb
    Helpful URLs:
#&gt;

function Get-OnlineVerGoogleChrome {
    [cmdletbinding()]
    param (
        [Parameter(Mandatory = $false, 
            Position = 0)]
        [switch]
        $Quiet
    )

    begin {
        # Initial Variables
        $SoftwareName = 'GoogleChrome'
        $URI = 'http://feeds.feedburner.com/GoogleChromeReleases'
            
        $hashtable = [ordered]@{
            'Software_Name'    = $softwareName
            'Software_URL'     = $uri
            'Online_Version'   = 'UNKNOWN' 
            'Online_Date'      = 'UNKNOWN'
            'Download_URL_x86' = 'UNKNOWN'
            'Download_URL_x64' = 'UNKNOWN'
        }
    
        $swObject = New-Object -TypeName PSObject -Property $hashtable
    }


    Process {
        # Get the Version &amp; Release Date
        try {
            Write-Verbose -Message "Attempting to pull info from the below URL: `n $URI"
            $uri = 'http://feeds.feedburner.com/GoogleChromeReleases'
            $rawReq = Invoke-WebRequest -Uri $URI -UseBasicParsing
            [xml]$strReleaseFeed = Invoke-WebRequest $uri -UseBasicParsing
            [string]$version = ($strReleaseFeed.feed.entry | Where-Object { $_.title.'#text' -match 'Stable' }).content | Select-Object { $_.'#text' } | Where-Object { $_ -match 'Windows' } | ForEach-Object { [version](($_ | Select-String -allmatches '(\d{1,4}\.){3}(\d{1,4})').matches | Select-Object -first 1 -expandProperty Value) } | Sort-Object -Descending | Select-Object -first 1
            $releaseDate = ($strReleaseFeed.feed.entry | Where-Object { $_.title.'#text' -match 'Stable' } | Select-Object -First 1).published
            $releaseDate = $releaseDate.Substring(0, 10) 

            $swObject.Online_Version = $version
            $swObject.Online_Date = $releaseDate

        }
        catch {
            Write-Verbose -Message "Error accessing the below URL: `n $URI"
            $message = $("Line {0} : {1}" -f $_.InvocationInfo.ScriptLineNumber, $_.exception.message)
            $swObject | Add-Member -MemberType NoteProperty -Name 'ERROR' -Value $message
        }
        finally {
          

            # Get the Download URLs
            if ($swObject.Online_Version -ne 'UNKNOWN') {
                $simpleVer = $version.Replace('.', '')
                $swObject.Download_URL_x86 = "https://dl.google.com/dl/chrome/install/googlechromestandaloneenterprise64.msi"
                $swObject.Download_URL_x64 = "https://dl.google.com/dl/chrome/install/googlechromestandaloneenterprise.msi"
            }
        }
    }
    End {
        # Output to Host
        if ($Quiet) {
            Write-Verbose -Message '$Quiet was specified. Returning just the version'
            Return $swObject.Online_Version
        }
        else {
            Return $swobject
        }
    }
}  # END Function Get-OnlineVerGoogleChrome
Get-OnlineVerGoogleChrome</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get-OnlineVerGoogleChrome</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>&lt;# 
 .NOTES
 ===========================================================================
  Created with:  PowerShell ISE (Win10 17134)
  Revision: v6
  Last Modified: 05 September 2018
  Created by:    Jay Harper (github.com/thecatdidit/powershellusefulscripts)
  Organizaiton:  Happy Days Are Here Again
  Filename:      Get-OnlineVerNotepadPlusPlus.ps1
 ===========================================================================
    .SYNOPSIS
        Queries Notepad++ Website for the current version of
        the app and returns the version, date updated, and
        download URLs if available.
    .DESCRIPTION
        This function retrieves the latest data associated with Notepad++.
        Utilizes Invoke-WebRequest to query NotepadPlusPlus Download Page and
        pulls out the Version, Update Date and Download URLs for both
        x86 and x64 versions. It then outputs the information as a
        PSObject to the Host.
    .INPUTS
        -Quiet
            Use of this parameter will output just the current version of
            Google Chrome instead of the entire object. It will always be the
            last parameter.
    .OUTPUTS
        An object containing the following:
        Software Name: Name of the software
        Software URL: The URL info was sourced from
        Online Version: The current version found
        Online Date: The date the version was updated
        Download URL x86: Download URL for the win32 version
        Download URL x64: Download URL for the win64 version
    
        If -Quiet is specified then just the value of 'Online Version'
        will be displayed.
    .EXAMPLE
        PS C:\&gt; Get-OnlineVerNotePadPlusPlus
 Software_Name    : NotepadPlusPlus
        Software_URL     : https://notepad-plus-plus.org/download
        Online_Version   : 7.5.8
        Online_Date      : 2018-07-23
        Download_URL_x86 : https://notepad-plus-plus.org/repository/7.x/7.5.8/npp.7.5.8.Installer.x86.exe
        Download_URL_x64 : https://notepad-plus-plus.org/repository/7.x/7.5.8/npp.7.5.8.Installer.x64.exe
        PS C:\&gt; Get-OnlineVerNotePadPlusPlus -Quiet
        7.5.8
    .NOTES
        Resources/Credits:
        https://github.com/itsontheb
#&gt;

function Get-OnlineVerNotepadPlusPlus {
    [cmdletbinding()]
    param (
        [Parameter(Mandatory = $false, 
            Position = 0)]
        [switch]
        $Quiet
    )

    begin {
        # Initial Variables
        $SoftwareName = 'NotepadPlusPlus'
        $URI = 'https://notepad-plus-plus.org/download'
            
        $hashtable = [ordered]@{
            'Software_Name'    = $softwareName
            'Software_URL'     = $uri
            'Online_Version'   = 'UNKNOWN' 
            'Online_Date'      = 'UNKNOWN'
            'Download_URL_x86' = 'UNKNOWN'
            'Download_URL_x64' = 'UNKNOWN'
        }
    
        $swObject = New-Object -TypeName PSObject -Property $hashtable
    }


    Process {
        # Get the Version &amp; Release Date
        try {
            Write-Verbose -Message "Attempting to pull info from the below URL: `n $URI"
            $uri = 'https://notepad-plus-plus.org/download'
            $nppURL = (Invoke-WebRequest -Uri $uri | Select-Object -ExpandProperty Content)
            $nppURL -match "&lt;title&gt;Notepad\+\+ v(?&lt;content&gt;.*) - Current Version&lt;/title&gt;" | Out-Null
            $nppVersion = ($matches['content'])
            $nppURL -match "&lt;p&gt;Release Date: (?&lt;content&gt;.*)&lt;/p&gt;" | Out-Null
            $nppDate = ($matches['content'])
            
            $swObject.Online_Version = $nppVersion
            $swObject.Online_Date = $nppDate

        }
        catch {
            Write-Verbose -Message "Error accessing the below URL: `n $URI"
            $message = $("Line {0} : {1}" -f $_.InvocationInfo.ScriptLineNumber, $_.exception.message)
            $swObject | Add-Member -MemberType NoteProperty -Name 'ERROR' -Value $message
        }
        finally {
          

            # Get the Download URLs
            if ($swObject.Online_Version -ne 'UNKNOWN') {
       
                $nppDownloadx86 = "https://notepad-plus-plus.org/repository/" + $nppVersion[0] + ".x/" + $nppVersion + "/" + "npp." + $nppVersion + ".Installer.x86.exe"
                $nppDownloadx64 = "https://notepad-plus-plus.org/repository/" + $nppVersion[0] + ".x/" + $nppVersion + "/" + "npp." + $nppVersion + ".Installer.x64.exe"
            
                $swObject.Download_URL_x86 = $nppDownloadx86
                $swObject.Download_URL_x64 = $nppDownloadx64
            }
        }
    }
    End {
        # Output to Host
        if ($Quiet) {
            Write-Verbose -Message '$Quiet was specified. Returning just the version'
            Return $swObject.Online_Version
        }
        else {
            Return $swobject
        }
    }
}  # END Function Get-OnlineVerNotepadPlusPlus
Get-OnlineVerNotepadPlusPlus</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get-OnlineVerNotepadPlusPlus</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>&lt;# 
 .NOTES
 ===========================================================================
  Created with:  PowerShell ISE (Win10 17134)
  Revision:  v1
  Last Modified: 30 March 2019
  Created by:    Jay Harper (github.com/thecatdidit/powershellusefulscripts)
  Organizaiton:  Happy Days Are Here Again
  Filename:      Get-OnlineVerWinSCP.ps1
 ===========================================================================
 .Synopsis
        Queries the WinSCP Website for the current version of
        the app and returns the version, date updated, and
        download URLs if available.
    .DESCRIPTION
     This function retrieves the latest data associated with WinSCP
        Utilizes Invoke-WebRequest to query the Postman download page and
        pulls out the Version, Update Date and Download URLs for
        the app (x64 only) It then outputs the information as a
        PSObject to the Host.
    .EXAMPLE
        PS C:\&gt; Get-OnlineVerWinSCP
        
        Software_Name    : WinSCP
        Software_URL     : https://winscp.net/eng/news.php
        Online_Version   : 5.15
        Online_Date      : 2019-03-27
        Download_URL_x64 : https://winscp.net/download/WinSCP-5.15-Setup.exe
        
    .INPUTS
        -Quiet
            Use of this parameter will output just the current version of
            Google Chrome instead of the entire object. It will always be the
            last parameter.
        PS C:\&gt; Get-OnlineVerBlueJeans -Quiet
        5.15
 .OUTPUTS
        An object containing the following:
        Software Name: Name of the software
        Software URL: The URL info was sourced from
        Online Version: The current version found
        Online Date: The date the version was updated
        Download URL x64: Download URL for the win64 version
    
        If -Quiet is specified then just the value of 'Online Version'
        will be displayed.
 .NOTES
    Resources/Credits:
    https://github.com/itsontheb
#&gt;


function Get-OnlineVerWinSCP
{
    [cmdletbinding()]
    param (
        [Parameter(Mandatory=$false, 
                   Position=0)]
        [switch]
        $Quiet
    )

    begin
    {
        # Initial Variables
        $SoftwareName = 'WinSCP'
        $uri = "https://winscp.net/eng/news.php"
            
        $hashtable = [ordered]@{
            'Software_Name'    = $softwareName
            'Software_URL'     = $uri
            'Online_Version'   = 'UNKNOWN' 
            'Online_Date'      = 'UNKNOWN'
            'Download_URL_x64' = 'UNKNOWN'
        }
    
        $swObject = New-Object -TypeName PSObject -Property $hashtable
}


   Process
    {
        # Get the Version &amp; Release Date
        try
        {
  
        $site = (Invoke-WebRequest -uri $uri -UseBasicParsing).Content

        $site -match "&lt;p class=""items-list-blocks-item-date""&gt;&lt;span class=""sr-only""&gt;Published:&lt;/span&gt;(?&lt;date&gt;.*)&lt;/p&gt;" | Out-Null
        $winscpdate = $matches['date']

        $site -match "&lt;h2 class=""items-list-blocks-item-heading""&gt;WinSCP (?&lt;version&gt;.*) released&lt;/h2&gt;" | Out-Null
        $winscpVersion = $matches['version']

        $winscpURL = "https://winscp.net/download/WinSCP-" + $winscpVersion + "-Setup.exe"
        
        $swObject.Online_Version = $winscpVersion
        $swObject.Online_Date = $winscpdate
        $swObject.Download_URL_x64 = $winscpURL
 
         }
        catch
        {
            Write-Verbose -Message "Error accessing the below URL: `n $URI"
            $message = $("Line {0} : {1}" -f $_.InvocationInfo.ScriptLineNumber, $_.exception.message)
            $swObject | Add-Member -MemberType NoteProperty -Name 'ERROR' -Value $message
        }
        finally
        {
   
    }
    }
    End
    {
        # Output to Host
        if ($Quiet)
        {
            Write-Verbose -Message '$Quiet was specified. Returning just the version'
            Return $swObject.Online_Version
        }
        else
        {
            Return $swobject
        }
    }
}  # END Function Get-OnlineVerWinSCP
Get-OnlineVerWinSCP</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get-OnlineVerWinSCP</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (3) (1)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Cleans</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>:: This empties all recycle bins on Windows 7 and up
rmdir /s /q %SystemDrive%\$Recycle.Bin 2&gt;NUL

:: This empties all recycle bins on Windows XP and Server 2003
rmdir /s /q %SystemDrive%\RECYCLER 2&gt;NUL

:: Return exit code to calling application
exit /B 0</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Icon-CommandStep</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Clean Corbeille</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI /v LastLoggedOnSAMUser /t REG_DWORD /d 0 /f
REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI /v LastLoggedOnUser /t REG_DWORD /d 0 /f
REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI /v LastLoggedOnUserSID /t REG_DWORD /d 0 /f
REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI /v SelectedUserSID /t REG_DWORD /d 0 /f
REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI /v LastLoggedOnDisplayName /t REG_DWORD /d 0 /f</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Icon-CommandStep</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Clear Last User (Login Screen)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>:: Purpose:       Temp file cleanup
:: Requirements:  Admin access helps but is not required
:: Author:        reddit.com/user/vocatus ( vocatus.gate at gmail ) // PGP key: 0x07d1490f82a211a2
:: Version:       3.7.1 ! Fix syntax bug that was preventing CBS log cleanup. Thanks to github:jonasjovaisas
::                3.7.0 * Improve logging significantly. Wrap all references to %LOGPATH% and %LOGFILE% in quotes (to protect against paths or file names with spaces or special characters), and add logging to many commands that were previously dumping to NUL. Thanks to github:kezxo for the suggestion
::                3.6.0 + Add additional cleaning procedures to Vista+ block from tron edition of TempFileCleanup. Thanks to github:bknickelbine
::                3.5.9 + Add removal of "%WINDIR%\System32\tourstart.exe" on Windows XP. Thanks to /u/Perma_dude
::                3.5.8 ! Move IE ClearMyTracksByProcess to Vista and up section (does not run on XP/2003)
::                3.5.7 * Add /u/neonicacid's suggestion to purge leftover NVIDIA driver installation files
::                3.5.6 * Merge nemchik's pull request to delete .blf and.regtrans-ms files (ported from Tron project)
::                      * Merge nemchik's pull request to purge Flash and Java temp locations (ported from Tron project)
::                3.5.5 + Add purging of additional old Windows version locations (left in place from Upgrade installations)
::                3.5.4 + Add purging of queued Windows Error Reporting reports. Thanks to /u/neonicacid
::                &lt;-- outdated changelog comments removed --&gt;
::                1.0.0   Initial write
SETLOCAL


:::::::::::::::
:: VARIABLES :: -------------- These are the defaults. Change them if you so desire. --------- ::
:::::::::::::::
:: Set your paths here. Don't use trailing slashes (\) in directory paths
set LOGPATH=%SystemDrive%\Logs
set LOGFILE=%COMPUTERNAME%_TempFileCleanup.log
:: Max log file size allowed in bytes before rotation and archive. 1048576 bytes is one megabyte
set LOG_MAX_SIZE=2097152




:: --------------------------- Don't edit anything below this line --------------------------- ::




:::::::::::::::::::::
:: PREP AND CHECKS ::
:::::::::::::::::::::
@echo off
%SystemDrive% &amp;&amp; cls
set SCRIPT_VERSION=3.7.1
set SCRIPT_UPDATED=2017-12-18
:: Get the date into ISO 8601 standard format (yyyy-mm-dd) so we can use it
FOR /f %%a in ('WMIC OS GET LocalDateTime ^| find "."') DO set DTS=%%a
set CUR_DATE=%DTS:~0,4%-%DTS:~4,2%-%DTS:~6,2%

title [TempFileCleanup v%SCRIPT_VERSION%]


:::::::::::::::::::::::
:: LOG FILE HANDLING ::
:::::::::::::::::::::::
:: Make the logfile if it doesn't exist
if not exist %LOGPATH% mkdir %LOGPATH%
if not exist %LOGPATH%\%LOGFILE% echo. &gt; %LOGPATH%\%LOGFILE%

:: Check log size. If it's less than our max, then jump to the cleanup section
for %%R in (%LOGPATH%\%LOGFILE%) do IF %%~zR LSS %LOG_MAX_SIZE% goto os_version_detection

:: If the log was too big, go ahead and rotate it.
pushd %LOGPATH%
del %LOGFILE%.ancient 2&gt;NUL
rename %LOGFILE%.oldest %LOGFILE%.ancient 2&gt;NUL
rename %LOGFILE%.older %LOGFILE%.oldest 2&gt;NUL
rename %LOGFILE%.old %LOGFILE%.older 2&gt;NUL
rename %LOGFILE% %LOGFILE%.old 2&gt;NUL
popd



::::::::::::::::::::::::::
:: OS VERSION DETECTION ::
::::::::::::::::::::::::::
:os_version_detection
:: Detect the version of Windows we're on. This determines a few things later in the script
set WIN_VER=undetected
for /f "tokens=3*" %%i IN ('reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v ProductName ^| Find "ProductName"') DO set WIN_VER=%%i %%j



::::::::::::::::::::::::::
:: USER CLEANUP SECTION :: -- Most stuff in here doesn't require Admin rights
::::::::::::::::::::::::::
:: Create the log header for this job
echo --------------------------------------------------------------------------------------------&gt;&gt; %LOGPATH%\%LOGFILE%
echo  %CUR_DATE% %TIME%  TempFileCleanup v%SCRIPT_VERSION%, executing as %USERDOMAIN%\%USERNAME%&gt;&gt; %LOGPATH%\%LOGFILE%
echo --------------------------------------------------------------------------------------------&gt;&gt; %LOGPATH%\%LOGFILE%
echo.
echo  Starting temp file cleanup
echo  --------------------------
echo.
echo   Cleaning USER temp files...


::::::::::::::::::::::
:: Version-agnostic :: (these jobs run regardless of OS version)
::::::::::::::::::::::
:: Create log line
echo. &gt;&gt; "%LOGPATH%\%LOGFILE%" %% echo  ! Cleaning USER temp files...&gt;&gt; "%LOGPATH%\%LOGFILE%" %% echo.&gt;&gt; "%LOGPATH%\%LOGFILE%"

:: User temp files, history, and random My Documents stuff
del /F /S /Q "%TEMP%" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL

:: Previous Windows versions cleanup. These are left behind after upgrading an installation from XP/Vista/7/8 to a higher version. Thanks to /u/bodkov and others
if exist %SystemDrive%\Windows.old\ (
 takeown /F %SystemDrive%\Windows.old\* /R /A /D Y&gt;&gt; "%LOGPATH%\%LOGFILE%"
 echo y| cacls %SystemDrive%\Windows.old\*.* /C /T /grant administrators:F&gt;&gt; "%LOGPATH%\%LOGFILE%"
 rmdir /S /Q %SystemDrive%\Windows.old\&gt;&gt; "%LOGPATH%\%LOGFILE%"
 )
if exist %SystemDrive%\$Windows.~BT\ (
 takeown /F %SystemDrive%\$Windows.~BT\* /R /A&gt;&gt; "%LOGPATH%\%LOGFILE%"
 icacls %SystemDrive%\$Windows.~BT\*.* /T /grant administrators:F&gt;&gt; "%LOGPATH%\%LOGFILE%"
 rmdir /S /Q %SystemDrive%\$Windows.~BT\&gt;&gt; "%LOGPATH%\%LOGFILE%"
 )
if exist %SystemDrive%\$Windows.~WS (
 takeown /F %SystemDrive%\$Windows.~WS\* /R /A&gt;&gt; "%LOGPATH%\%LOGFILE%"
 icacls %SystemDrive%\$Windows.~WS\*.* /T /grant administrators:F&gt;&gt; "%LOGPATH%\%LOGFILE%"
 rmdir /S /Q %SystemDrive%\$Windows.~WS\&gt;&gt; "%LOGPATH%\%LOGFILE%"
 )


::::::::::::::::::::::
:: Version-specific :: (these jobs run depending on OS version)
::::::::::::::::::::::
:: First block handles XP/2k3, second block handles Vista and up
:: Read 9 characters into the WIN_VER variable. Only versions of Windows older than Vista had "Microsoft" as the first part of their title,
:: so if we don't find "Microsoft" in the first 9 characters we can safely assume we're not on XP/2k3.
if /i "%WIN_VER:~0,9%"=="Microsoft" (
 for /D %%x in ("%SystemDrive%\Documents and Settings\*") do (
  del /F /Q "%%x\Local Settings\Temp\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /Q "%%x\Recent\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /Q "%%x\Local Settings\Temporary Internet Files\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /Q "%%x\Local Settings\Application Data\ApplicationHistory\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /Q "%%x\My Documents\*.tmp" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /Q "%%x\Application Data\Sun\Java\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /Q "%%x\Application Data\Adobe\Flash Player\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /Q "%%x\Application Data\Macromedia\Flash Player\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
 )
) else (
 for /D %%x in ("%SystemDrive%\Users\*") do (
  del /F /S /Q "%%x\*.blf" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\*.regtrans-ms" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\LocalLow\Sun\Java\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Google\Chrome\User Data\Default\Cache\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Google\Chrome\User Data\Default\JumpListIconsOld\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Google\Chrome\User Data\Default\JumpListIcons\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Google\Chrome\User Data\Default\Local Storage\http*.*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Google\Chrome\User Data\Default\Media Cache\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Microsoft\Internet Explorer\Recovery\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Microsoft\Terminal Server Client\Cache\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Microsoft\Windows\Caches\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Microsoft\Windows\Explorer\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Microsoft\Windows\History\low\*" /AH 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Microsoft\Windows\INetCache\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Microsoft\Windows\Temporary Internet Files\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Microsoft\Windows\WebCache\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Local\Temp\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Roaming\Adobe\Flash Player\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Roaming\Macromedia\Flash Player\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\AppData\Roaming\Microsoft\Windows\Recent\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /S /Q "%%x\Recent\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  del /F /Q "%%x\Documents\*.tmp" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  :: Internet Explorer cleanup
  rundll32.exe inetcpl.cpl,ClearMyTracksByProcess 4351
 )
)


echo. &amp;&amp; echo   Done. &amp;&amp; echo.
echo. &gt;&gt; "%LOGPATH%\%LOGFILE%" &amp;&amp; echo   Done.&gt;&gt; "%LOGPATH%\%LOGFILE%" &amp;&amp; echo. &gt;&gt;%LOGPATH%\%LOGFILE%



::::::::::::::::::::::::::::
:: SYSTEM CLEANUP SECTION :: -- Most stuff here requires Admin rights
::::::::::::::::::::::::::::
echo.
echo   Cleaning SYSTEM temp files...
echo   Cleaning SYSTEM temp files... &gt;&gt; "%LOGPATH%\%LOGFILE%" &amp;&amp; echo.&gt;&gt; %LOGPATH%\%LOGFILE%


::::::::::::::::::::::
:: Version-agnostic :: (these jobs run regardless of OS version)
::::::::::::::::::::::
:: JOB: System temp files
del /F /S /Q "%WINDIR%\TEMP\*" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL

:: JOB: Root drive garbage (usually C drive)
rmdir /S /Q %SystemDrive%\Temp &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
for %%i in (bat,txt,log,jpg,jpeg,tmp,bak,backup,exe) do (
   del /F /Q "%SystemDrive%\*.%%i"&gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  )

:: JOB: Remove files left over from installing Nvidia/ATI/AMD/Dell/Intel/HP drivers
for %%i in (NVIDIA,ATI,AMD,Dell,Intel,HP) do (
   rmdir /S /Q "%SystemDrive%\%%i" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  )

:: JOB: Clear additional unneeded files from NVIDIA driver installs
if exist "%ProgramFiles%\Nvidia Corporation\Installer2" rmdir /s /q "%ProgramFiles%\Nvidia Corporation\Installer2"
if exist "%ALLUSERSPROFILE%\NVIDIA Corporation\NetService" del /f /q "%ALLUSERSPROFILE%\NVIDIA Corporation\NetService\*.exe"

:: JOB: Remove the Microsoft Office installation cache. Usually around ~1.5 GB
if exist %SystemDrive%\MSOCache rmdir /S /Q %SystemDrive%\MSOCache &gt;&gt; "%LOGPATH%\%LOGFILE%"

:: JOB: Remove the Microsoft Windows installation cache. Can be up to 1.0 GB
if exist %SystemDrive%\i386 rmdir /S /Q %SystemDrive%\i386 &gt;&gt; "%LOGPATH%\%LOGFILE%"

:: JOB: Empty all recycle bins on Windows 5.1 (XP/2k3) and 6.x (Vista and up) systems
if exist %SystemDrive%\RECYCLER rmdir /s /q %SystemDrive%\RECYCLER
if exist %SystemDrive%\$Recycle.Bin rmdir /s /q %SystemDrive%\$Recycle.Bin

:: JOB: Clear queued and archived Windows Error Reporting (WER) reports
echo. &gt;&gt; "%LOGPATH%\%LOGFILE%"
if exist "%USERPROFILE%\AppData\Local\Microsoft\Windows\WER\ReportArchive" rmdir /s /q "%USERPROFILE%\AppData\Local\Microsoft\Windows\WER\ReportArchive"
if exist "%USERPROFILE%\AppData\Local\Microsoft\Windows\WER\ReportQueue" rmdir /s /q "%USERPROFILE%\AppData\Local\Microsoft\Windows\WER\ReportQueue"
if exist "%ALLUSERSPROFILE%\Microsoft\Windows\WER\ReportArchive" rmdir /s /q "%ALLUSERSPROFILE%\Microsoft\Windows\WER\ReportArchive"
if exist "%ALLUSERSPROFILE%\Microsoft\Windows\WER\ReportQueue" rmdir /s /q "%ALLUSERSPROFILE%\Microsoft\Windows\WER\ReportQueue"

:: JOB: Windows update logs &amp; built-in backgrounds (space waste)
del /F /Q %WINDIR%\*.log &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
del /F /Q %WINDIR%\*.txt &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
del /F /Q %WINDIR%\*.bmp &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
del /F /Q %WINDIR%\*.tmp &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
del /F /Q %WINDIR%\Web\Wallpaper\*.* &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
rmdir /S /Q %WINDIR%\Web\Wallpaper\Dell &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL

:: JOB: Flash cookies (both locations)
rmdir /S /Q "%APPDATA%\Macromedia\Flash Player\#SharedObjects" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
rmdir /S /Q "%APPDATA%\Macromedia\Flash Player\macromedia.com\support\flashplayer\sys" &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL

::::::::::::::::::::::
:: Version-specific :: (these jobs run depending on OS version)
::::::::::::::::::::::
:: JOB: Windows XP/2k3: "guided tour" annoyance
if /i "%WIN_VER:~0,9%"=="Microsoft" (
 del /f /q %WINDIR%\system32\dllcache\tourstrt.exe 2&gt;NUL
 del /f /q %WINDIR%\system32\dllcache\tourW.exe 2&gt;NUL
 del /f /q "%WINDIR%\System32\tourstart.exe"
 rmdir /S /Q %WINDIR%\Help\Tours 2&gt;NUL
 )

:: JOB: Disable Windows Tour bubble popup (Windows XP only; new user accounts only)
if /i "%WIN_VER:~0,9%"=="Microsoft" reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Applets\Tour" /v RunCount /t REG_DWORD /d 00000000 /f

:: JOB: Windows Server: remove built-in media files (all Server versions)
echo %WIN_VER%  | findstr /i /%SystemDrive%"server" &gt;NUL
if %ERRORLEVEL%==0 (
 echo.
 echo  ! Server operating system detected.
 echo    Removing built-in media files ^(.wav, .midi, etc^)...
 echo.
 echo. &gt;&gt; "%LOGPATH%\%LOGFILE%" &amp;&amp; echo  ! Server operating system detected. Removing built-in media files ^(.wave, .midi, etc^)...&gt;&gt; "%LOGPATH%\%LOGFILE%" &amp;&amp; echo. &gt;&gt; "%LOGPATH%\%LOGFILE%"

 :: 2. Take ownership of the files so we can actually delete them. By default even Administrators have Read-only rights.
 echo    Taking ownership of %WINDIR%\Media in order to delete files... &amp;&amp; echo.
 echo    Taking ownership of %WINDIR%\Media in order to delete files... &gt;&gt; "%LOGPATH%\%LOGFILE%" &amp;&amp; echo.&gt;&gt; "%LOGPATH%\%LOGFILE%"
 if exist %WINDIR%\Media takeown /f %WINDIR%\Media /r /d y &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL &amp;&amp; echo.&gt;&gt; "%LOGPATH%\%LOGFILE%"
 if exist %WINDIR%\Media icacls %WINDIR%\Media /grant administrators:F /t &gt;&gt; "%LOGPATH%\%LOGFILE%" &amp;&amp; echo.&gt;&gt; "%LOGPATH%\%LOGFILE%"

 :: 3. Do the cleanup
 rmdir /S /Q %WINDIR%\Media&gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL

 echo    Done.
 echo.
 echo    Done.&gt;&gt; "%LOGPATH%\%LOGFILE%"
 echo.&gt;&gt; "%LOGPATH%\%LOGFILE%"
 )

:: JOB: Windows CBS logs
::      these only exist on Vista and up, so we look for "Microsoft", and assuming we don't find it, clear out the folder
echo %WIN_VER% | findstr /v /i /c:"Microsoft" &gt;NUL &amp;&amp; del /F /Q %WINDIR%\Logs\CBS\* 2&gt;NUL

:: JOB: Windows XP/2003: Cleanup hotfix uninstallers. They use a lot of space so removing them is beneficial.
:: Really we should use a tool that deletes their corresponding registry entries, but oh well.

::  0. Check Windows version.
::    We simply look for "Microsoft" in the version name, because only versions prior to Vista had the word "Microsoft" as part of their version name
::    Everything after XP/2k3 drops the "Microsoft" prefix
echo %WIN_VER%  | findstr /i /%SystemDrive%"Microsoft" &gt;NUL
if %ERRORLEVEL%==0 (
 :: 1. If we made it here we're doing the cleanup. Notify user and log it.
 echo.
 echo  ! Windows XP/2003 detected.
 echo    Removing hotfix uninstallers...
 echo.
 echo. &gt;&gt; "%LOGPATH%\%LOGFILE%" &amp;&amp; echo  ! Windows XP/2003 detected. Removing hotfix uninstallers...&gt;&gt; %LOGPATH%\%LOGFILE%

 :: 2. Build the list of hotfix folders. They always have "$" signs around their name, e.g. "$NtUninstall092330$" or "$hf_mg$"
 pushd %WINDIR%
 dir /A:D /B $*$ &gt; %TEMP%\hotfix_nuke_list.txt 2&gt;NUL

 :: 3. Do the hotfix clean up
 for /f %%i in (%TEMP%\hotfix_nuke_list.txt) do (
  echo Deleting %%i...
  echo Deleted folder %%i&gt;&gt; "%LOGPATH%\%LOGFILE%"
  rmdir /S /Q %%i &gt;&gt; "%LOGPATH%\%LOGFILE%" 2&gt;NUL
  )

 :: 4. Log that we are done with hotfix cleanup and leave the Windows directory
 echo    Done. &gt;&gt; "%LOGPATH%\%LOGFILE%" &amp;&amp; echo.&gt;&gt; %LOGPATH%\%LOGFILE%
 echo    Done.
 del %TEMP%\hotfix_nuke_list.txt&gt;&gt; %LOGPATH%\%LOGFILE%
 echo.
 popd
)

echo   Done. &amp;&amp; echo.
echo   Done.&gt;&gt; "%LOGPATH%\%LOGFILE%" &amp;&amp; echo. &gt;&gt;%LOGPATH%\%LOGFILE%

::::::::::::::::::::::::::
:: Cleanup and complete ::
::::::::::::::::::::::::::
:complete
@echo off
echo --------------------------------------------------------------------------------------------&gt;&gt; %LOGPATH%\%LOGFILE%
echo  %CUR_DATE% %TIME%  TempFileCleanup v%SCRIPT_VERSION%, finished. Executed as %USERDOMAIN%\%USERNAME%&gt;&gt; %LOGPATH%\%LOGFILE%&gt;&gt; %LOGPATH%\%LOGFILE%
echo --------------------------------------------------------------------------------------------&gt;&gt; %LOGPATH%\%LOGFILE%
echo.
echo  Cleanup complete.
echo.
echo  Log saved at: %LOGPATH%\%LOGFILE%
echo.
ENDLOCAL</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Icon-CommandStep</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Clean Temp Files</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>$Date = (Get-Date).AddHours(-2)

Stop-Service spooler
Sleep 5
Get-ChildItem -Path "C:\Windows\System32\spool\PRINTERS" | Where-Object { $_.LastWriteTime -lt $Date } | Remove-Item -Verbose
Start-Service spooler</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Clean Spooler</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Relance du spouleur pour affichage de l'imprimante
Set-Service -Name Spooler -StartupType Automatic
Stop-Service -name Spooler -Force
Start-service -name Spooler</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Reset Spooler</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (5) (1)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Kris's Bag of Holding</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>System</CustomToolType>
          <CommandLine>%WINDIR%\System32\mmc.exe dsa.msc</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>NoShell</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Stock0520</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Active Directory Users and Computers</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>System</CustomToolType>
          <CommandLine>@echo off
Echo Executing on:
Echo    %COMPUTERNAME%
Echo.
Echo Description: 
Echo    Refresh Group Policy settings.
Echo.
Echo Command:
Echo    gpupdate
Echo.
Echo Output:
Echo.

gpupdate</CommandLine>
          <DefaultIconKey>Icon-Hardware</DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Icon-CommandStep</IconKey>
          <KeyGesture></KeyGesture>
          <Title>gpupdate (local)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>System</CustomToolType>
          <CommandLine>while($true){
    Get-SmbConnection
    Start-Sleep 1
    Clear-Host
}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get SMB Connections (local)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>System</CustomToolType>
          <CommandLine>while($true){
    Get-SmbConnection
    Start-Sleep 1
    Clear-Host
}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get SMB Connections (Remote PowerShell)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>$Pattern   = '^(?&lt;IP&gt;\d{1,3}(\.\d{1,3}){3})\s+(?&lt;Host&gt;.+)$'
$Entries   = @()
$Computer = "$(Computer:TARGET)"

$file = "\\$Computer\c$\Windows\System32\Drivers\etc\hosts"
(Get-Content -Path $File) | ForEach-Object {
    If ($_ -match $Pattern) {
        
        $Entries += "$computer,$($Matches.IP),$($Matches.Host)"
    
    }
}

$Entries</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get HOSTS file entries (local)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$Pattern   = '^(?&lt;IP&gt;\d{1,3}(\.\d{1,3}){3})\s+(?&lt;Host&gt;.+)$'
$Entries   = @()

$file = "C:\Windows\System32\Drivers\etc\hosts"
(Get-Content -Path $File) | ForEach-Object {
    If ($_ -match $Pattern) {
        
        $Entries += "$env:ComputerName,$($Matches.IP),$($Matches.Host)"
    
    }
}

$Entries</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Get HOSTS file entries (remote)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>@echo off
Echo Description: 
Echo    Reports information about what woke the system from the last sleep transition.
Echo.
Echo Command:
Echo    psexec \\$(Computer:TARGET) -accepteula powercfg /lastwake
Echo.
Echo Output:
psexec \\$(Computer:TARGET) -accepteula powercfg /lastwake</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Icon-CommandStep</IconKey>
          <KeyGesture></KeyGesture>
          <Title>PowerCfg - Lastwake</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>"C:\Program Files (x86)\WinDirStat\WinDirStat.exe" \\$(Computer:TARGETHOSTNAME)\c$\</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>CloseShell</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Stock0200</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Disks - WinDirStat C:\</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <FolderComputerTool>
          <Description></Description>
          <IconKey>Icon-Folder</IconKey>
          <KeyGesture></KeyGesture>
          <Title>SysInternals Examples</Title>
          <TypeName>FolderComputerTool</TypeName>
          <Children type="list">
            <CustomTool>
              <CredentialsId value="null" />
              <RunAs>Admin</RunAs>
              <ScanAfter>DoNotScan</ScanAfter>
              <ScanProfileId value="null" />
              <SuccessCodesText>0</SuccessCodesText>
              <Timeout>00:03:00</Timeout>
              <WakeOnLan value="false" />
              <CustomToolType>Local</CustomToolType>
              <CommandLine>@Echo off
Echo Starting command shell on $(Computer:TARGET)

psexec \\$(Computer:TARGETHOSTNAME) -accepteula cmd</CommandLine>
              <DefaultIconKey></DefaultIconKey>
              <LibraryToolId value="null" />
              <Modified value="null" />
              <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
              <Mode>Command</Mode>
              <Description></Description>
              <IconKey>Icon-CommandStep</IconKey>
              <KeyGesture></KeyGesture>
              <Title>psexec - cmd</Title>
              <TypeName>CustomTool</TypeName>
            </CustomTool>
            <CustomTool>
              <CredentialsId value="null" />
              <RunAs>Admin</RunAs>
              <ScanAfter>DoNotScan</ScanAfter>
              <ScanProfileId value="null" />
              <SuccessCodesText>0</SuccessCodesText>
              <Timeout>00:03:00</Timeout>
              <WakeOnLan value="false" />
              <CustomToolType>Local</CustomToolType>
              <CommandLine>@Echo off
Echo Get process information for $(Computer:TARGET)
Mode con: cols=80 lines=49

pslist -st \\$(Computer:TARGETHOSTNAME) -accepteula</CommandLine>
              <DefaultIconKey></DefaultIconKey>
              <LibraryToolId value="null" />
              <Modified value="null" />
              <ShellOpenMode>CloseShell</ShellOpenMode>
              <Mode>Command</Mode>
              <Description></Description>
              <IconKey>Icon-CommandStep</IconKey>
              <KeyGesture></KeyGesture>
              <Title>pslist -st</Title>
              <TypeName>CustomTool</TypeName>
            </CustomTool>
          </Children>
        </FolderComputerTool>
        <FolderComputerTool>
          <Description></Description>
          <IconKey>Icon-Folder</IconKey>
          <KeyGesture></KeyGesture>
          <Title>PuTTY Examples</Title>
          <TypeName>FolderComputerTool</TypeName>
          <Children type="list">
            <CustomTool>
              <CredentialsId value="null" />
              <RunAs>Admin</RunAs>
              <ScanAfter>DoNotScan</ScanAfter>
              <ScanProfileId value="null" />
              <SuccessCodesText>0</SuccessCodesText>
              <Timeout>00:03:00</Timeout>
              <WakeOnLan value="false" />
              <CustomToolType>Local</CustomToolType>
              <CommandLine>putty.exe -telnet $(Computer:TARGETIPADDRESS)</CommandLine>
              <DefaultIconKey></DefaultIconKey>
              <LibraryToolId value="null" />
              <Modified value="null" />
              <ShellOpenMode>NoShell</ShellOpenMode>
              <Mode>Command</Mode>
              <Description></Description>
              <IconKey>Icon-CommandStep</IconKey>
              <KeyGesture></KeyGesture>
              <Title>putty - Telnet</Title>
              <TypeName>CustomTool</TypeName>
            </CustomTool>
            <CustomTool>
              <CredentialsId value="null" />
              <RunAs>Admin</RunAs>
              <ScanAfter>DoNotScan</ScanAfter>
              <ScanProfileId value="null" />
              <SuccessCodesText>0</SuccessCodesText>
              <Timeout>00:03:00</Timeout>
              <WakeOnLan value="false" />
              <CustomToolType>Local</CustomToolType>
              <CommandLine>putty.exe -rlogin $(Computer:TARGETIPADDRESS)</CommandLine>
              <DefaultIconKey></DefaultIconKey>
              <LibraryToolId value="null" />
              <Modified value="null" />
              <ShellOpenMode>NoShell</ShellOpenMode>
              <Mode>Command</Mode>
              <Description></Description>
              <IconKey>Icon-CommandStep</IconKey>
              <KeyGesture></KeyGesture>
              <Title>putty - rlogin</Title>
              <TypeName>CustomTool</TypeName>
            </CustomTool>
            <CustomTool>
              <CredentialsId value="null" />
              <RunAs>Admin</RunAs>
              <ScanAfter>DoNotScan</ScanAfter>
              <ScanProfileId value="null" />
              <SuccessCodesText>0</SuccessCodesText>
              <Timeout>00:03:00</Timeout>
              <WakeOnLan value="false" />
              <CustomToolType>Local</CustomToolType>
              <CommandLine>putty.exe -ssh %UserName%@$(Computer:TARGETIPADDRESS)"</CommandLine>
              <DefaultIconKey></DefaultIconKey>
              <LibraryToolId value="null" />
              <Modified value="null" />
              <ShellOpenMode>CloseShell</ShellOpenMode>
              <Mode>Command</Mode>
              <Description></Description>
              <IconKey>Icon-CommandStep</IconKey>
              <KeyGesture></KeyGesture>
              <Title>putty - ssh</Title>
              <TypeName>CustomTool</TypeName>
            </CustomTool>
          </Children>
        </FolderComputerTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (2) (1)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Launcher</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LoggedOnUser</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Lancement de Internet Explorer avec un chemin précis
Start-Process -FilePath "C:\Program Files\internet explorer\iexplore.exe"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock4050</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Lancement IExplore - LOGGED ON USER</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LoggedOnUser</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Arrêt du processus *iexplore*
Stop-Process -Name *iexplore* -WarningAction Ignore</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock4050</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Arrêt IExplore - LOGGED ON USER</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LoggedOnUser</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Lancement de Teams avec un chemin avec variable
Start-Process -FilePath "$env:USERPROFILE\AppData\Local\Microsoft\Teams\current\teams.exe"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock4050</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Lancement Teams - LOGGED ON USER</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LoggedOnUser</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Arrêt du processus *teams*
Stop-Process -Name *teams* -WarningAction Ignore</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock4050</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Arrêt Teams - LOGGED ON USER</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LoggedOnUser</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Lancement de Firefox avec un chemin précis
Start-Process -Filepath "C:\Program Files (x86)\Mozilla Firefox\firefox.exe" -WarningAction Ignore</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock4050</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Lancement Firefox - LOGGED ON USER</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LoggedOnUser</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Arrêt du processus *firefox*
Stop-Process -Name *Firefox* -WarningAction Ignore</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock4050</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Arrêt Firefox - LOGGED ON USER</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (4)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Set Default Browser - To check</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>xcopy "\\sccm2012\e$\SCCM_Repository\Software\Scripts\DefaultBrowser\SetDefaultBrowser.exe" "C:\temp" /Y /C

C:\temp\SetDefaultBrowser.exe HKLM "FIREFOX.EXE"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Stock4030</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Set Default Browser - Firefox (Nightly)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>xcopy "\\sccm2012\e$\SCCM_Repository\Software\Scripts\DefaultBrowser\SetDefaultBrowser.exe" "C:\temp" /Y /C

C:\temp\SetDefaultBrowser.exe HKLM "Google Chrome"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Stock4030</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Set Default Browser - Chrome</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>xcopy "\\sccm2012\e$\SCCM_Repository\Software\Scripts\DefaultBrowser\SetDefaultBrowser.exe" "C:\temp" /Y /C

C:\temp\SetDefaultBrowser.exe HKLM "EDGE"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Stock4030</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Set Default Browser - Edge</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>xcopy "\\sccm2012\e$\SCCM_Repository\Software\Scripts\DefaultBrowser\SetDefaultBrowser.exe" "C:\temp" /Y /C

C:\temp\SetDefaultBrowser.exe HKLM "IEXPLORE.EXE</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Stock4030</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Set Default Browser - IExplore</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (1)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>WLan ; Lan</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>Set-Service -Name Wlansvc -StartupType Automatic
Start-service -name Wlansvc</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0050</IconKey>
          <KeyGesture></KeyGesture>
          <Title>WLan - Activation</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>Stop-service -name Wlansvc
Set-Service -Name Wlansvc -StartupType Disabled</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0050</IconKey>
          <KeyGesture></KeyGesture>
          <Title>WLan - Désactivation</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$IPType = "IPv4"
$adapter = Get-NetAdapter | ? {$_.Status -eq "up"}
$interface = $adapter | Get-NetIPInterface -AddressFamily $IPType
If ($interface.Dhcp -eq "Disabled") {
 # Remove existing gateway
 If (($interface | Get-NetIPConfiguration).Ipv4DefaultGateway) {
 $interface | Remove-NetRoute -Confirm:$false
 }
 # Enable DHCP
 $interface | Set-NetIPInterface -DHCP Enabled
 # Configure the DNS Servers automatically
 $interface | Set-DnsClientServerAddress -ResetServerAddresses
}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Stock0055</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Set DHCP (Win10)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$IP = Read-host "IP souhaitée ?"
$MaskBits = Read-host "Mask Bits souhaités ? (16, 24..)" # This means subnet mask = 255.255.255.0
$Gateway = Read-host "Gateway souhaitée ?"
$Dns = Read-host "DNS souhaité ?"
$IPType = "IPv4"
# Retrieve the network adapter that you want to configure
$adapter = Get-NetAdapter | ? {$_.Status -eq "up"}
# Remove any existing IP, gateway from our ipv4 adapter
If (($adapter | Get-NetIPConfiguration).IPv4Address.IPAddress) {
 $adapter | Remove-NetIPAddress -AddressFamily $IPType -Confirm:$false
}
If (($adapter | Get-NetIPConfiguration).Ipv4DefaultGateway) {
 $adapter | Remove-NetRoute -AddressFamily $IPType -Confirm:$false
}
 # Configure the IP address and default gateway
$adapter | New-NetIPAddress `
 -AddressFamily $IPType `
 -IPAddress $IP `
 -PrefixLength $MaskBits `
 -DefaultGateway $Gateway
# Configure the DNS client server IP addresses
$adapter #| Set-DnsClientServerAddress -ServerAddresses $DNS</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Stock0055</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Set Static IP (Win10)</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine></CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>ACTIVABLE / DESACTIVABLE</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Reg Import "\\sccm2012\e$\SCCM_Repository\Software\Scripts\ExplorerSettings\DoNotHideExtensions.reg"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0895</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Afficher les Extensions - Activation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Reg Import "\\sccm2012\e$\SCCM_Repository\Software\Scripts\ExplorerSettings\HideExtensions.reg"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0895</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Afficher les Extensions - Désactivation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>@echo off
rem :: =============================Configuration Autologon==============================================================
rem :: =============================CH Avignon ::::::::::::==============================================================
rem :: =============================Auteur : Haïlé Toybou : Version 1:: =================================================

Reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaveActive /t REG_SZ /d 0 /f

Powercfg /H OFF

Powercfg -change -monitor-timeout-ac 0

rem :: Reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaveTimeOut /t REG_SZ /d 0 /f

Reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Power\PowerSettings\7516b95f-f776-4464-8c53-06167f40cc99\8EC4B3A5-6868-48c2-BE75-4F3044BE88A7" /v Attributes /t REG_DWORD /d 2 /f

Rem :: THE END :::</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock1040</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Désactivation Veille &amp; Hibernation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Reg Import "\\sccm2012\e$\SCCM_Repository\Software\Scripts\KillNotResponding\Add_Kill_Not_Responding_Tasks.reg"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock3020</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Kill not Responding - Activation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Reg Import "\\sccm2012\e$\SCCM_Repository\Software\Scripts\KillNotResponding\Remove_Kill_Not_Responding_Tasks.reg"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock3020</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Kill not Responding - Désactivation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>$kbObj = New-Object -ComObject WScript.Shell 
$nlStatus = [console]::NumberLock 
If ($nlStatus -eq $false) 
 {$kbObj.SendKeys('{NUMLOCK}')} 
Else  
 {exit}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock4020</IconKey>
      <KeyGesture></KeyGesture>
      <Title>NumLock - Activation Auto</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Reg import "\\sccm2012\e$\SCCM_Repository\Software\Scripts\OpenCMDHere\Win7\Add_CMDAsAdmin_win7.reg"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0895</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Open CMD Here as Admin Win7 -Activation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Reg import "\\sccm2012\e$\SCCM_Repository\Software\Scripts\OpenCMDHere\Win10\Add_CMDAsAdmin_win10.reg"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0895</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Open CMD Here as Admin Win10 -Activation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Reg import "\\sccm2012\e$\SCCM_Repository\Software\Scripts\OpenCMDHere\Remove_CMDAsAdmin.reg"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0895</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Open CMD Here as Admin -Désactivation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Reg Import "\\sccm2012\e$\SCCM_Repository\Software\Scripts\ExplorerSettings\PowershellOnContextMenu.reg"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0895</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Open Powershell Here - Activation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Set-Service -Name Mpssvc -StartupType Automatic
start-service -name MpsSvc
netsh advfirewall set allprofiles state off
# netsh advfirewall firewall set rule group="File and Printer Sharing" new enable=Yes</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Icon-PowerShell</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Pare-Feu - Activation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Stop-service -name mpssvc
Set-Service -Name Mpssvc -StartupType Disabled</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Icon-PowerShell</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Pare-Feu - Désactivation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>:: Script to enable Remote Desktop on a machine
:: Thanks to reddit.com/user/diggity801 for idea and initial script

:: Open the firewall to allow incoming connections
netsh advfirewall firewall set rule group="Remote Desktop" new enable=Yes

:: Disable the "Deny TS Connections" registry key
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f

:: Set the service to start automatically at boot time
sc config termservice start= auto

:: Start the service
net start termservice</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0055</IconKey>
      <KeyGesture></KeyGesture>
      <Title>RDP - Activation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>bcdedit /set {default} recoveryenabled No 
bcdedit /set {default} bootstatuspolicy ignoreallfailures</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>NoShell</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0220</IconKey>
      <KeyGesture></KeyGesture>
      <Title>StartUp Repair - Désactivation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (1)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>####################################################################################
#.Synopsis 
#    List members of a local group on a remote computer.
#
#.Parameter ComputerName 
#    Name of the local or remote computer.  Defaults to the local computer.
#    Can be an array of computer names instead of just one name.
#
#.Parameter LocalGroupName
#    Name of the local group whose membership is to be listed.  If the group
#    name contains spaces, use quotes.  Defaults to Administrators.
#
#.Parameter CommaSeparatedOutput
#    Outputs a comma-delimited string for each group member instead of one 
#    object per computer with a an array of members as a property.
#
#Requires -Version 2.0 
#
#.Notes 
#  Author: Jason Fossen, Enclave Consulting LLC (http://www.sans.org/sec505) 
# Version: 2.0
# Updated: 20.Jan.2015
#   LEGAL: PUBLIC DOMAIN.  SCRIPT PROVIDED "AS IS" WITH NO WARRANTIES OR GUARANTEES OF 
#          ANY KIND, INCLUDING BUT NOT LIMITED TO MERCHANTABILITY AND/OR FITNESS FOR
#          A PARTICULAR PURPOSE.  ALL RISKS OF DAMAGE REMAINS WITH THE USER, EVEN IF
#          THE AUTHOR, SUPPLIER OR DISTRIBUTOR HAS BEEN ADVISED OF THE POSSIBILITY OF
#          ANY SUCH DAMAGE.  IF YOUR STATE DOES NOT PERMIT THE COMPLETE LIMITATION OF
#          LIABILITY, THEN DELETE THIS FILE SINCE YOU ARE NOW PROHIBITED TO HAVE IT.
####################################################################################


Param ($ComputerName = "$env:ComputerName", $LocalGroupName = "Administrateurs", [Switch] $CommaSeparatedOutput)


function Get-LocalGroupMembership ($ComputerName = "$env:ComputerName", $LocalGroupName = "Administrateurs", [Switch] $CommaSeparatedOutput)
{
    # Construct an object whose properties will hold the output of the function
    $Output = ( $Output = ' ' | select-object ComputerName,LocalGroupName,TimeOfCheck,Members ) 
    $Output.ComputerName = $ComputerName
    $Output.LocalGroupName = $LocalGroupName
    $Output.TimeOfCheck = get-date 
        


    # Create a WMI query for the membership of the local group.
    $query = "SELECT * FROM Win32_GroupUser WHERE GroupComponent=`"Win32_Group.Domain='$ComputerName',Name='$LocalGroupName'`""


    # Try to connect to the target computer; function should return nothing if there is an error while connecting.
    Try   { $members = Get-WmiObject -computer $ComputerName -query $query -ErrorAction Stop } 
    Catch { Write-Error -Message "Could not connect to $ComputerName" ; Return } 


    # This array will hold the list of members in the group so that it can be attached to the $output.
    $MembersList = @()


    # Carve the strings out to extract just the names, put each into "domain\user" format.
    ForEach ($member in $members) 
    {
        $domainuser = $member.PartComponent | select-string -pattern 'Domain="(.+)",Name=\"(.+)"' -AllMatches | 
                      select-object -expand Matches | select-object -expand Groups

        $MembersList += $domainuser[1].Value + "\" + $domainuser[2].Value
    }


    # By default, output an object, but comma-delimited strings can be output instead with -CommaSeparatedOutput.
    if ($CommaSeparatedOutput)
    {
        $MembersList | ForEach { $Output.ComputerName + ',' + $Output.LocalGroupName + ',' + $_ + ',' + $Output.TimeOfCheck } 
    }
    else
    {
        $Output.Members = $MembersList
        $Output
    } 
}




# Instead of a single computer name, the script can accept an array of computer names,
# so each name in the array, even if only one, should be processed:

[System.Array] $ComputersToScan += $ComputerName

ForEach ($Box In $ComputersToScan)
{ 
    $AdminLoc = Get-LocalGroupMembership -ComputerName $Box -LocalGroupName $LocalGroupName -CommaSeparatedOutput:$CommaSeparatedOutput  #| Select-Object -Property Members
    $AdminLoc.members
}









# Note that the above function has little error handling or other niceties, it's intended
# as a teaching script which can be easily modified later.  To save the output, pipe
# into Export-CliXml, not into Export-Csv, which causes the member names to be lost.</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0520</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Get Local Admins</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>C:\Users\AGasparoux\Downloads\Get-ComputerHealth.ps1 $(Computer:TARGETHOSTNAME) &gt; C:\temp\health.txt</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>CloseShell</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Icon-PowerShell</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Get ComputerHealth - ToDo</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>#documentation: https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/windows-scripting/x83z1d9f(v=vs.84)

$title = "Informatique - Centre Hospitalier D'avignon"
$message = "Service Informatique. Merci de bien vouloir me contacter au 37 94, s'il vous plait"
$secondsToWait = 120 # seconds for the window to be visible. 0 seconds will wait until user closes the window.
$wshell = New-Object -ComObject Wscript.Shell # Create message box object
$exitcode = $wshell.Popup($message, $secondsToWait, $title, 0x1031) #1000 = start on top; 0030 = warning icon; 0001 = Ok/Cancel buttons
# $exitcode 1 = OK button, 2 = Cancel button, -1 = Msg box closed after $seconsdToWait timed out
exit $exitcode</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock1500</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Message 120s</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine># For a discussion of this setting and its impact, see:
# http://technet.microsoft.com/en-us/magazine/2007.01.cableguy.aspx
# The intent is to optimize TCP performance by setting the
# receive window auto-tuning level to Disabled.




# To disable TCP/IP autotunning, in an elevated CMD shell run:

netsh.exe interface tcp set global autotuninglevel= Disabled



# To see current TCP global settings and to confirm 
# that "Receive Window Auto-Tuning Level" is disabled:

netsh.exe interface tcp show global



# To reset back to the factory default:
#netsh.exe interface tcp set global autotuninglevel= normal</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Icon-PowerShell</IconKey>
      <KeyGesture></KeyGesture>
      <Title>TCPI/IP Optimisation</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>10:00:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>:: Purpose:      Simple script to check if a host is online and turn the window green (up) or red (down) based on the result. Also logs the result to a file
:: Requirements: Windows XP and up
:: Author:       reddit.com/user/vocatus ( vocatus.gate at gmail ) // PGP key: 0x07d1490f82a211a2
:: Version:      1.2.1 ! Fix date not correctly updating at start of each check
::               1.2.0 * Rework CUR_DATE to use function we call instead of static conversion
::               1.1.0 * Reworked CUR_DATE variable to handle more than one Date/Time format
::                       Can now handle all Windows date formats
::               1.0.0   Initial write


::::::::::
:: Prep :: -- Don't change anything in this section
::::::::::
@echo off
set SCRIPT_VERSION=1.2.1
set SCRIPT_UPDATED=2016-05-10
cls
call :set_cur_date

:::::::::::::::
:: VARIABLES :: -- Set these to your desired values
:::::::::::::::
:: Set host to check here
set HOST=$(Computer:TARGET)
set DISPLAY_NAME="FRIENDLY DISPLAY NAME HERE (DOESN'T AFFECT SCRIPT FUNCTION)"
set LOGFILE=C:\Temp\pingup_%DISPLAY_NAME%.log
set PINGS_PER_CHECK=1
set RECHECK_COOLDOWN_DELAY=5


:::::::::::::
:: EXECUTE ::
:::::::::::::
echo %CUR_DATE% %TIME%   Initializng PINGUP monitoring script
echo                          Executing as %USERDOMAIN%\%USERNAME% on '%COMPUTERNAME%'
echo                          Monitoring:       %HOST% (%DISPLAY_NAME%)
echo                          Pings per check:  %PINGS_PER_CHECK%
echo                          Recheck cooldown: %RECHECK_COOLDOWN_DELAY%

echo %CUR_DATE% %TIME%   Initializng PINGUP monitoring script&gt;&gt; %LOGFILE%
echo                          Executing as %USERDOMAIN%\%USERNAME% on '%COMPUTERNAME%'&gt;&gt; %LOGFILE%
echo                          Monitoring:       %HOST% (%DISPLAY_NAME%)&gt;&gt; %LOGFILE%
echo                          Pings per check:  %PINGS_PER_CHECK%&gt;&gt; %LOGFILE%
echo                          Recheck cooldown: %RECHECK_COOLDOWN_DELAY%&gt;&gt; %LOGFILE%

echo.
echo %CUR_DATE% %TIME%   Performing initial test...
echo %CUR_DATE% %TIME%   Performing initial test...&gt;&gt; %LOGFILE%
echo.


:start
call :set_cur_date
ping %HOST% -n %PINGS_PER_CHECK% | find /i "TTL" &gt; nul


:::::::::::::
:: HOST UP ::
:::::::::::::
:: Host is UP: Black text on green background
if %ERRORLEVEL%==0 (
 title UP: %HOST% 
 color a0
 echo %CUR_DATE% %TIME%   Host %HOST% ^(%DISPLAY_NAME%^) up.
 echo %CUR_DATE% %TIME%   Host %HOST% ^(%DISPLAY_NAME%^) up.&gt;&gt; %LOGFILE%
) ELSE (
 REM Host is DOWN: Black text on red background 
 title DWN: %HOST%
 color c0
 echo %CUR_DATE% %TIME% ! Host %HOST% ^(%DISPLAY_NAME%^) down.
 echo %CUR_DATE% %TIME% ! Host %HOST% ^(%DISPLAY_NAME%^) down.&gt;&gt; %LOGFILE%
)


:: Cooldown until next check
ping localhost -n 2 &gt;NUL
goto start


:::::::::::::::
:: FUNCTIONS ::
:::::::::::::::
:: Get the date into ISO 8601 standard format (yyyy-mm-dd) so we can use it 
:set_cur_date
for /f %%a in ('WMIC OS GET LocalDateTime ^| find "."') DO set DTS=%%a
set CUR_DATE=%DTS:~0,4%-%DTS:~4,2%-%DTS:~6,2%
goto :eof</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Icon-CommandStep</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Pincheck 5s</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Function Set-ScreenResolution { 
 
&lt;# 
    .Synopsis 
        Sets the Screen Resolution of the primary monitor 
    .Description 
        Uses Pinvoke and ChangeDisplaySettings Win32API to make the change 
    .Example 
        Set-ScreenResolution -Width 1024 -Height 768         
    #&gt; 
param ( 
[Parameter(Mandatory=$true, 
           Position = 0)] 
[int] 
$Width, 
 
[Parameter(Mandatory=$true, 
           Position = 1)] 
[int] 
$Height 
) 
 
$pinvokeCode = @" 
 
using System; 
using System.Runtime.InteropServices; 
 
namespace Resolution 
{ 
 
    [StructLayout(LayoutKind.Sequential)] 
    public struct DEVMODE1 
    { 
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)] 
        public string dmDeviceName; 
        public short dmSpecVersion; 
        public short dmDriverVersion; 
        public short dmSize; 
        public short dmDriverExtra; 
        public int dmFields; 
 
        public short dmOrientation; 
        public short dmPaperSize; 
        public short dmPaperLength; 
        public short dmPaperWidth; 
 
        public short dmScale; 
        public short dmCopies; 
        public short dmDefaultSource; 
        public short dmPrintQuality; 
        public short dmColor; 
        public short dmDuplex; 
        public short dmYResolution; 
        public short dmTTOption; 
        public short dmCollate; 
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)] 
        public string dmFormName; 
        public short dmLogPixels; 
        public short dmBitsPerPel; 
        public int dmPelsWidth; 
        public int dmPelsHeight; 
 
        public int dmDisplayFlags; 
        public int dmDisplayFrequency; 
 
        public int dmICMMethod; 
        public int dmICMIntent; 
        public int dmMediaType; 
        public int dmDitherType; 
        public int dmReserved1; 
        public int dmReserved2; 
 
        public int dmPanningWidth; 
        public int dmPanningHeight; 
    }; 
 
 
 
    class User_32 
    { 
        [DllImport("user32.dll")] 
        public static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE1 devMode); 
        [DllImport("user32.dll")] 
        public static extern int ChangeDisplaySettings(ref DEVMODE1 devMode, int flags); 
 
        public const int ENUM_CURRENT_SETTINGS = -1; 
        public const int CDS_UPDATEREGISTRY = 0x01; 
        public const int CDS_TEST = 0x02; 
        public const int DISP_CHANGE_SUCCESSFUL = 0; 
        public const int DISP_CHANGE_RESTART = 1; 
        public const int DISP_CHANGE_FAILED = -1; 
    } 
 
 
 
    public class PrmaryScreenResolution 
    { 
        static public string ChangeResolution(int width, int height) 
        { 
 
            DEVMODE1 dm = GetDevMode1(); 
 
            if (0 != User_32.EnumDisplaySettings(null, User_32.ENUM_CURRENT_SETTINGS, ref dm)) 
            { 
 
                dm.dmPelsWidth = width; 
                dm.dmPelsHeight = height; 
 
                int iRet = User_32.ChangeDisplaySettings(ref dm, User_32.CDS_TEST); 
 
                if (iRet == User_32.DISP_CHANGE_FAILED) 
                { 
                    return "Unable To Process Your Request. Sorry For This Inconvenience."; 
                } 
                else 
                { 
                    iRet = User_32.ChangeDisplaySettings(ref dm, User_32.CDS_UPDATEREGISTRY); 
                    switch (iRet) 
                    { 
                        case User_32.DISP_CHANGE_SUCCESSFUL: 
                            { 
                                return "Success"; 
                            } 
                        case User_32.DISP_CHANGE_RESTART: 
                            { 
                                return "You Need To Reboot For The Change To Happen.\n If You Feel Any Problem After Rebooting Your Machine\nThen Try To Change Resolution In Safe Mode."; 
                            } 
                        default: 
                            { 
                                return "Failed To Change The Resolution"; 
                            } 
                    } 
 
                } 
 
 
            } 
            else 
            { 
                return "Failed To Change The Resolution."; 
            } 
        } 
 
        private static DEVMODE1 GetDevMode1() 
        { 
            DEVMODE1 dm = new DEVMODE1(); 
            dm.dmDeviceName = new String(new char[32]); 
            dm.dmFormName = new String(new char[32]); 
            dm.dmSize = (short)Marshal.SizeOf(dm); 
            return dm; 
        } 
    } 
} 
 
"@ 
 
Add-Type $pinvokeCode -ErrorAction SilentlyContinue 
[Resolution.PrmaryScreenResolution]::ChangeResolution($width,$height) 
} 
Set-ScreenResolution -Width 1440 -Height 900</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0010</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Résolution 19" 1440*900</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Function Set-ScreenResolution { 
 
&lt;# 
    .Synopsis 
        Sets the Screen Resolution of the primary monitor 
    .Description 
        Uses Pinvoke and ChangeDisplaySettings Win32API to make the change 
    .Example 
        Set-ScreenResolution -Width 1024 -Height 768         
    #&gt; 
param ( 
[Parameter(Mandatory=$true, 
           Position = 0)] 
[int] 
$Width, 
 
[Parameter(Mandatory=$true, 
           Position = 1)] 
[int] 
$Height 
) 
 
$pinvokeCode = @" 
 
using System; 
using System.Runtime.InteropServices; 
 
namespace Resolution 
{ 
 
    [StructLayout(LayoutKind.Sequential)] 
    public struct DEVMODE1 
    { 
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)] 
        public string dmDeviceName; 
        public short dmSpecVersion; 
        public short dmDriverVersion; 
        public short dmSize; 
        public short dmDriverExtra; 
        public int dmFields; 
 
        public short dmOrientation; 
        public short dmPaperSize; 
        public short dmPaperLength; 
        public short dmPaperWidth; 
 
        public short dmScale; 
        public short dmCopies; 
        public short dmDefaultSource; 
        public short dmPrintQuality; 
        public short dmColor; 
        public short dmDuplex; 
        public short dmYResolution; 
        public short dmTTOption; 
        public short dmCollate; 
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)] 
        public string dmFormName; 
        public short dmLogPixels; 
        public short dmBitsPerPel; 
        public int dmPelsWidth; 
        public int dmPelsHeight; 
 
        public int dmDisplayFlags; 
        public int dmDisplayFrequency; 
 
        public int dmICMMethod; 
        public int dmICMIntent; 
        public int dmMediaType; 
        public int dmDitherType; 
        public int dmReserved1; 
        public int dmReserved2; 
 
        public int dmPanningWidth; 
        public int dmPanningHeight; 
    }; 
 
 
 
    class User_32 
    { 
        [DllImport("user32.dll")] 
        public static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE1 devMode); 
        [DllImport("user32.dll")] 
        public static extern int ChangeDisplaySettings(ref DEVMODE1 devMode, int flags); 
 
        public const int ENUM_CURRENT_SETTINGS = -1; 
        public const int CDS_UPDATEREGISTRY = 0x01; 
        public const int CDS_TEST = 0x02; 
        public const int DISP_CHANGE_SUCCESSFUL = 0; 
        public const int DISP_CHANGE_RESTART = 1; 
        public const int DISP_CHANGE_FAILED = -1; 
    } 
 
 
 
    public class PrmaryScreenResolution 
    { 
        static public string ChangeResolution(int width, int height) 
        { 
 
            DEVMODE1 dm = GetDevMode1(); 
 
            if (0 != User_32.EnumDisplaySettings(null, User_32.ENUM_CURRENT_SETTINGS, ref dm)) 
            { 
 
                dm.dmPelsWidth = width; 
                dm.dmPelsHeight = height; 
 
                int iRet = User_32.ChangeDisplaySettings(ref dm, User_32.CDS_TEST); 
 
                if (iRet == User_32.DISP_CHANGE_FAILED) 
                { 
                    return "Unable To Process Your Request. Sorry For This Inconvenience."; 
                } 
                else 
                { 
                    iRet = User_32.ChangeDisplaySettings(ref dm, User_32.CDS_UPDATEREGISTRY); 
                    switch (iRet) 
                    { 
                        case User_32.DISP_CHANGE_SUCCESSFUL: 
                            { 
                                return "Success"; 
                            } 
                        case User_32.DISP_CHANGE_RESTART: 
                            { 
                                return "You Need To Reboot For The Change To Happen.\n If You Feel Any Problem After Rebooting Your Machine\nThen Try To Change Resolution In Safe Mode."; 
                            } 
                        default: 
                            { 
                                return "Failed To Change The Resolution"; 
                            } 
                    } 
 
                } 
 
 
            } 
            else 
            { 
                return "Failed To Change The Resolution."; 
            } 
        } 
 
        private static DEVMODE1 GetDevMode1() 
        { 
            DEVMODE1 dm = new DEVMODE1(); 
            dm.dmDeviceName = new String(new char[32]); 
            dm.dmFormName = new String(new char[32]); 
            dm.dmSize = (short)Marshal.SizeOf(dm); 
            return dm; 
        } 
    } 
} 
 
"@ 
 
Add-Type $pinvokeCode -ErrorAction SilentlyContinue 
[Resolution.PrmaryScreenResolution]::ChangeResolution($width,$height) 
} 
Set-ScreenResolution -Width 1600 -Height 900</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0010</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Résolution 24" 1600*900</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>Function Set-ScreenResolution { 
 
&lt;# 
    .Synopsis 
        Sets the Screen Resolution of the primary monitor 
    .Description 
        Uses Pinvoke and ChangeDisplaySettings Win32API to make the change 
    .Example 
        Set-ScreenResolution -Width 1024 -Height 768         
    #&gt; 
param ( 
[Parameter(Mandatory=$true, 
           Position = 0)] 
[int] 
$Width, 
 
[Parameter(Mandatory=$true, 
           Position = 1)] 
[int] 
$Height 
) 
 
$pinvokeCode = @" 
 
using System; 
using System.Runtime.InteropServices; 
 
namespace Resolution 
{ 
 
    [StructLayout(LayoutKind.Sequential)] 
    public struct DEVMODE1 
    { 
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)] 
        public string dmDeviceName; 
        public short dmSpecVersion; 
        public short dmDriverVersion; 
        public short dmSize; 
        public short dmDriverExtra; 
        public int dmFields; 
 
        public short dmOrientation; 
        public short dmPaperSize; 
        public short dmPaperLength; 
        public short dmPaperWidth; 
 
        public short dmScale; 
        public short dmCopies; 
        public short dmDefaultSource; 
        public short dmPrintQuality; 
        public short dmColor; 
        public short dmDuplex; 
        public short dmYResolution; 
        public short dmTTOption; 
        public short dmCollate; 
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)] 
        public string dmFormName; 
        public short dmLogPixels; 
        public short dmBitsPerPel; 
        public int dmPelsWidth; 
        public int dmPelsHeight; 
 
        public int dmDisplayFlags; 
        public int dmDisplayFrequency; 
 
        public int dmICMMethod; 
        public int dmICMIntent; 
        public int dmMediaType; 
        public int dmDitherType; 
        public int dmReserved1; 
        public int dmReserved2; 
 
        public int dmPanningWidth; 
        public int dmPanningHeight; 
    }; 
 
 
 
    class User_32 
    { 
        [DllImport("user32.dll")] 
        public static extern int EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE1 devMode); 
        [DllImport("user32.dll")] 
        public static extern int ChangeDisplaySettings(ref DEVMODE1 devMode, int flags); 
 
        public const int ENUM_CURRENT_SETTINGS = -1; 
        public const int CDS_UPDATEREGISTRY = 0x01; 
        public const int CDS_TEST = 0x02; 
        public const int DISP_CHANGE_SUCCESSFUL = 0; 
        public const int DISP_CHANGE_RESTART = 1; 
        public const int DISP_CHANGE_FAILED = -1; 
    } 
 
 
 
    public class PrmaryScreenResolution 
    { 
        static public string ChangeResolution(int width, int height) 
        { 
 
            DEVMODE1 dm = GetDevMode1(); 
 
            if (0 != User_32.EnumDisplaySettings(null, User_32.ENUM_CURRENT_SETTINGS, ref dm)) 
            { 
 
                dm.dmPelsWidth = width; 
                dm.dmPelsHeight = height; 
 
                int iRet = User_32.ChangeDisplaySettings(ref dm, User_32.CDS_TEST); 
 
                if (iRet == User_32.DISP_CHANGE_FAILED) 
                { 
                    return "Unable To Process Your Request. Sorry For This Inconvenience."; 
                } 
                else 
                { 
                    iRet = User_32.ChangeDisplaySettings(ref dm, User_32.CDS_UPDATEREGISTRY); 
                    switch (iRet) 
                    { 
                        case User_32.DISP_CHANGE_SUCCESSFUL: 
                            { 
                                return "Success"; 
                            } 
                        case User_32.DISP_CHANGE_RESTART: 
                            { 
                                return "You Need To Reboot For The Change To Happen.\n If You Feel Any Problem After Rebooting Your Machine\nThen Try To Change Resolution In Safe Mode."; 
                            } 
                        default: 
                            { 
                                return "Failed To Change The Resolution"; 
                            } 
                    } 
 
                } 
 
 
            } 
            else 
            { 
                return "Failed To Change The Resolution."; 
            } 
        } 
 
        private static DEVMODE1 GetDevMode1() 
        { 
            DEVMODE1 dm = new DEVMODE1(); 
            dm.dmDeviceName = new String(new char[32]); 
            dm.dmFormName = new String(new char[32]); 
            dm.dmSize = (short)Marshal.SizeOf(dm); 
            return dm; 
        } 
    } 
} 
 
"@ 
 
Add-Type $pinvokeCode -ErrorAction SilentlyContinue 
[Resolution.PrmaryScreenResolution]::ChangeResolution($width,$height) 
} 
Set-ScreenResolution -Width 1920 -Height 1080</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0010</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Résolution Full HD 1920*1080</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (5)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine></CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>TOOLS</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>System</CustomToolType>
      <CommandLine>@Echo off
Echo Flush the DNS Resolver Cache on your workstation
hostname 

ipconfig /flushdns</CommandLine>
      <DefaultIconKey>Icon-CommandStep</DefaultIconKey>
      <LibraryToolId value="40" />
      <Modified>2016-12-22T17:03:47.0000000+01:00</Modified>
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>Command</Mode>
      <Description>Use this to flush (empty) the DNS cache on your console machine. This can be necessary when a target’s IP address has changed but your DNS cache still has the old address. This tool is considered a “System Tool”. This means that a computer does not need to be selected to run it.</Description>
      <IconKey>Icon-CommandStep</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Flush DNS Resolver Cache (localhost)</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>ipconfig /registerdns</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Icon-CommandStep</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Register DNS</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>CScript.exe "\\srv-nas-info\adminArsenal$\Repository\Scripts\LogOffCurrentUser\LogOff.vbs"</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock1500</IconKey>
      <KeyGesture></KeyGesture>
      <Title>LogOff CurrentUser</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>LoggedOnUser</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>rundll32.exe user32.dll,LockWorkStation</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock1500</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Lock Remote Session - Logged On User</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>ScanAfter</ScanAfter>
      <ScanProfileId value="3" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>net user Administrateur /active:yes</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>Command</Mode>
      <Description></Description>
      <IconKey>Stock0510</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Activation Administrateur</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine># This script adds a user to the local administrators group
# provided that their username forms part of the computer 
# name. Executed as a post WDS task, we can get the computer
# out the door a little quicker.

#On récupère l'utilisateur loggué:
$ComputerInfos = Get-WmiObject -Class Win32_ComputerSystem
[String] ${stUserDomain},[String] ${stUserAccount} = $ComputerInfos.Username.split("\")

$username     = ${stUserAccount}
$computerName = $env:computername
$domain       = 'ADCHA'
$group        = [ADSI]"WinNT://$env:computername/Administrateurs,group"

 # Add the domain user as a member of the group
  $group.Add("WinNT://$domain/$username")</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Icon-PowerShell</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Ajout Logged User to Local Admins</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>[void][Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic')
$title = 'Remote PC Description' #title diplayed on message box
$msg   = 'Enter new description:' #message text displayed on message box
$text = [Microsoft.VisualBasic.Interaction]::InputBox($msg, $title)
$OSValues = Get-WmiObject -class Win32_OperatingSystem -computername "$(Computer:TARGETHOSTNAME)"
$OSValues.Description = $text
$OSValues.put()
Invoke-Command -ScriptBlock {pdqinventory ScanComputers -Computers "$(Computer:TARGETHOSTNAME)" -ScanProfile "Computer Info"}
exit</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Stock0890</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Changement Description Locale de l'Ordinateur</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>start http://$(Computer:TARGETIPADDRESS)</CommandLine>
      <DefaultIconKey>Icon-CommandStep</DefaultIconKey>
      <LibraryToolId value="49" />
      <Modified>2016-12-22T18:23:39.0000000+01:00</Modified>
      <ShellOpenMode>CloseShell</ShellOpenMode>
      <Mode>Command</Mode>
      <Description>If the target device has a webserver (such as a printer or IP Phone) this tool will attempt to start the default browser and connect to the IP address.</Description>
      <IconKey>Icon-CommandStep</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Connect to IP via HTTP</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>%SYSTEMROOT%\system32\mmc.exe lusrmgr.msc /computer=$(Computer:TARGETHOSTNAME)</CommandLine>
      <DefaultIconKey>Stock0520</DefaultIconKey>
      <LibraryToolId value="130" />
      <Modified>2017-02-06T19:21:18.0000000+01:00</Modified>
      <ShellOpenMode>NoShell</ShellOpenMode>
      <Mode>Command</Mode>
      <Description>Manage local user accounts and local groups on target computer.</Description>
      <IconKey>Stock0520</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Local Users and Groups Manager</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>&lt;#
#Script pour Renommer un ordinateur distant
#Alex
#&gt; 

cls
$work_dir = get-location | select -ExpandProperty Path
$work_dir = $work_dir + "\"
#run again with elevated permissions
if (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) 
    { 
    #Start-Process powershell.exe "-NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`"" -WorkingDirectory $work_dir -Verb RunAs; exit
    Start-Process powershell.exe -ArgumentList "-File $PSCommandPath", $work_dir -Verb RunAs 
    exit
    }

$pcName = (Get-WmiObject -ComputerName $(Computer:TARGETHOSTNAME) -Class win32_computersystem)
$pcNom = $pcName.Name

#------------------prompt for computer name--------------------
$pcNewName = Read-Host "Quel sera le nouveau Nom pour $pcNom ?"
#--------------------------------------------------------------

$pcName = Get-WmiObject -ComputerName $pcNom -Class win32_computersystem

Rename-Computer -ComputerName $pcNom -NewName $pcNewName -DomainCredential $admincredentials -Force -Restart


#-----------------------wait for any key-----------------------
read-host "press any key to continue"
#Write-Host "Press any key to continue ..."
#$x = $host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
#--------------------------------------------------------------

#Scan PDQ Inventory
Invoke-Command -ScriptBlock {pdqinventory ScanComputers -Computers "$(Computer:TARGET)" -ScanProfile "Standard"}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Icon-PowerShell</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Rename Remote Computer - REBOOT</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Remote</CustomToolType>
      <CommandLine>&lt;#PSScriptInfo 
.VERSION 1.0.0 
.GUID e009159d-97e2-492a-a289-42426518dd41 
.AUTHOR Arjun Bahree 
.COMPANYNAME 
.COPYRIGHT 
.TAGS Windows PowerShell DiskPartition OSDisk 
.LICENSEURI https://github.com/bahreex/Bahree-PowerShell-Library/blob/master/LICENSE 
.PROJECTURI https://github.com/bahreex/Bahree-PowerShell-Library/tree/master/General 
.ICONURI 
.EXTERNALMODULEDEPENDENCIES 
.REQUIREDSCRIPTS 
.EXTERNALSCRIPTDEPENDENCIES 
.RELEASENOTES 
#&gt;

&lt;# 
.DESCRIPTION 
 Lets you extend/Increase the OS Drive Partition Size for any Windows based Machine. 
#&gt; 

&lt;# 
.SYNOPSIS 
    Lets you extend/Increase the OS Drive Partition Size for any Windows based Machine. 
 
.DESCRIPTION 
    This script lets you extend/Increase the OS Drive Partition size for any Windows based Machine by adding the entire 
    unallocated space available on the OS Disk, if any. This script is particularly useful for extending the OS Drive 
    partition for Windows based Azure VM's, after the VM OS Disk size has been Increased from outside the VM using 
    PowerShell or Azure Portal. This is so because the Increase in size done for the VM OS Disk from outside does not 
    automatically get added to the OS Drive partition, and shows as unallocated space on the OS Disk of the VM. You will 
    have to manually extend the OS Drive partition from within the VM OS to add the unallocated space to the OS 
    partition. This script helps to automate the same process end-to-end. You need to be already logged into your Azure 
    account through PowerShell before calling this script. 
 
.EXAMPLE 
    .\Extend-WinOSDiskSize.ps1 
     
.Notes 
    Author: Arjun Bahree 
    E-mail: arjun.bahree@gmail.com 
    Creation Date: 28/Dec/2017 
    Last Revision Date: 28/Dec/2017 
    Development Environment: VS Code IDE 
    PS Version: 5.1 
    Platform: Windows 
#&gt;

[CmdletBinding()]
param ()    

# Iterate through all the disks on the Windows machine
foreach($disk in Get-Disk)
{
    # Check if the disk in context is a Boot and System disk
    if((Get-Disk -Number $disk.number).IsBoot -And (Get-Disk -Number $disk.number).IsSystem)
    {
        # Get the drive letter assigned to the disk partition where OS is installed
        $driveLetter = (Get-Partition -DiskNumber $disk.Number | where {$_.DriveLetter}).DriveLetter
        Write-verbose "Current OS Drive: $driveLetter :\"

        # Get current size of the OS parition on the Disk
        $currentOSDiskSize = (Get-Partition -DriveLetter $driveLetter).Size        
        Write-verbose "Current OS Partition Size: $currentOSDiskSize"

        # Get Partition Number of the OS partition on the Disk
        $partitionNum = (Get-Partition -DriveLetter $driveLetter).PartitionNumber
        Write-verbose "Current OS Partition Number: $partitionNum"

        # Get the available unallocated disk space size
        $unallocatedDiskSize = (Get-Disk -Number $disk.number).LargestFreeExtent
        Write-verbose "Total Unallocated Space Available: $unallocatedDiskSize"

        # Get the max allowed size for the OS Partition on the disk
        $allowedSize = (Get-PartitionSupportedSize -DiskNumber $disk.Number -PartitionNumber $partitionNum).SizeMax
        Write-verbose "Total Partition Size allowed: $allowedSize"

        if ($unallocatedDiskSize -gt 0 -And $unallocatedDiskSize -le $allowedSize)
        {
            $totalDiskSize = $allowedSize
            
            # Resize the OS Partition to Include the entire Unallocated disk space
            $resizeOp = Resize-Partition -DriveLetter C -Size $totalDiskSize
            Write-verbose "OS Drive Resize Completed $resizeOp"
        }
        else {
            Write-Verbose "There is no Unallocated space to extend OS Drive Partition size"
        }
    }   
}</CommandLine>
      <DefaultIconKey></DefaultIconKey>
      <LibraryToolId value="null" />
      <Modified value="null" />
      <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
      <Mode>PowerShell</Mode>
      <Description></Description>
      <IconKey>Icon-PowerShell</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Extend Unallocated Disk Space</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <CustomTool>
      <CredentialsId value="null" />
      <RunAs>Admin</RunAs>
      <ScanAfter>DoNotScan</ScanAfter>
      <ScanProfileId value="null" />
      <SuccessCodesText>0</SuccessCodesText>
      <Timeout>00:03:00</Timeout>
      <WakeOnLan value="false" />
      <CustomToolType>Local</CustomToolType>
      <CommandLine>%SYSTEMROOT%\system32\mmc.exe services.msc /computer:$(Computer:TARGETHOSTNAME)</CommandLine>
      <DefaultIconKey>Stock0830</DefaultIconKey>
      <LibraryToolId value="47" />
      <Modified>2016-12-22T17:03:21.0000000+01:00</Modified>
      <ShellOpenMode>NoShell</ShellOpenMode>
      <Mode>Command</Mode>
      <Description>Uses Services.msc to view/manage target’s Windows Services.</Description>
      <IconKey>Stock0830</IconKey>
      <KeyGesture>Ctrl+Shift+S</KeyGesture>
      <Title>Manage Services</Title>
      <TypeName>CustomTool</TypeName>
    </CustomTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (1)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
    <FolderComputerTool>
      <Description></Description>
      <IconKey>Icon-Folder</IconKey>
      <KeyGesture></KeyGesture>
      <Title>Exemples Tools</Title>
      <TypeName>FolderComputerTool</TypeName>
      <Children type="list">
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>Function CreateShortcut
{
    [CmdletBinding()]
    param ( 
     [parameter(Mandatory=$true)]
     [ValidateScript( {[IO.File]::Exists($_)} )]
     [System.IO.FileInfo] $Target,
 
     [ValidateScript( {[IO.Directory]::Exists($_)} )]
     [System.IO.DirectoryInfo] $OutputDirectory,
 
     [string] $Name,
     [string] $Description,
 
     [string] $Arguments,
     [System.IO.DirectoryInfo] $WorkingDirectory,
 
     [string] $HotKey,
     [int] $WindowStyle = 1,
     [string] $IconLocation,
     [switch] $Elevated
    )

    try {
     #region Create Shortcut
     if ($Name) {
      [System.IO.FileInfo] $LinkFileName = [System.IO.Path]::ChangeExtension($Name, "lnk")
     } else {
      [System.IO.FileInfo] $LinkFileName = [System.IO.Path]::ChangeExtension($Target.Name, "lnk")
     }
 
     if ($OutputDirectory) {
      [System.IO.FileInfo] $LinkFile = [IO.Path]::Combine($OutputDirectory, $LinkFileName)
     } else {
      [System.IO.FileInfo] $LinkFile = [IO.Path]::Combine($Target.Directory, $LinkFileName)
     }

       
     $wshshell = New-Object -ComObject WScript.Shell
     $shortCut = $wshShell.CreateShortCut($LinkFile) 
     $shortCut.TargetPath = $Target
     $shortCut.WindowStyle = $WindowStyle
     $shortCut.Description = $Description
     $shortCut.WorkingDirectory = $WorkingDirectory
     $shortCut.HotKey = $HotKey
     $shortCut.Arguments = $Arguments
     if ($IconLocation) {
      $shortCut.IconLocation = $IconLocation
     }
     $shortCut.Save()
     #endregion

     #region Elevation Flag
     if ($Elevated) {
      $tempFileName = [IO.Path]::GetRandomFileName()
      $tempFile = [IO.FileInfo][IO.Path]::Combine($LinkFile.Directory, $tempFileName)
  
      $writer = new-object System.IO.FileStream $tempFile, ([System.IO.FileMode]::Create)
      $reader = $LinkFile.OpenRead()
  
      while ($reader.Position -lt $reader.Length)
      {  
       $byte = $reader.ReadByte()
       if ($reader.Position -eq 22) {
        $byte = 34
       }
       $writer.WriteByte($byte)
      }
  
      $reader.Close()
      $writer.Close()
  
      $LinkFile.Delete()
  
      Rename-Item -Path $tempFile -NewName $LinkFile.Name
     }
     #endregion
    } catch {
     Write-Error "Failed to create shortcut. The error was '$_'."
     return $null
    }
    return $LinkFile
}

CreateShortcut -name "Notepad++ Admin" -Target "${env:ProgramFiles(x86)}\Notepad++\notepad++.exe" -OutputDirectory "C:\Users\Public\Desktop" -Elevated True</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Ajout Raccourcis Bureau</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#To dismiss a process you can use the process ID or the process name. The -processname switch allows the use of wildcards. Here's how to stop the calculator:

Stop-Process -processname Taskmgr</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Arrêt Processus distant</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LoggedOnUser</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#To dismiss a process you can use the process ID or the process name. The -processname switch allows the use of wildcards. Here's how to stop the calculator:

Start-Process -FilePath "C:\Program Files\comething\thing.exe"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Démarrage Processus distant - LOGGED ON USER</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>Send-MailMessage -From "Dieu@Paradis.org" -To "toto@hotmail.com" -Subject "Subject here" -Body "Message here" -SmtpServer "mailserv.domain"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Mail</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>#A l’aide de ce script que vous lancerez depuis une tâche planifiée, vous pourrez monitorer un service.
#Il suffit de renseigner(rajouter) les dernières ligne en dessous du script avec chacun de vos services à monitorer et après vous recevrez un email contenant tous les services arrêtés (ou vous ne recevrez pas d’email si tout est ok).

 

function VerifServices{
Param ([Parameter(Mandatory=$true)][String] $Service)
$Statut = (Get-Service $Service).Status
if ($Statut -match « Stopped »){ 
$global:Message = $global:Message + « &lt;li&gt;&lt;b&gt; » + $Service + « &lt;/b&gt;&lt;/li&gt; » 
} 
}

function Send-EmailServices {

if ( $global:Message -ne «  ») {
#envoi d’un email si des services sont arrêtés
# attention à bien les envoyés sur un mail externe à l’infra si vous devez surveiller Exchange par exemple 😉
$enc = New-Object System.Text.utf8encoding
$BodyMessage = « &lt;h2&gt;Des problèmes sont rencontrés sur le serveur &lt;/h2&gt;&lt;br&gt;&lt;br&gt;Services arrêtés :&lt;UL&gt; » + $global:Message + « &lt;/UL&gt; »
Send-MailMessage -From « moi@gmail.com » -To « moi@gmail.com » -Subject « Problème : Service(s) arrêté(s) » -Body $BodyMessage -SmtpServer « smtp.free.fr » -Priority High -BodyAsHtml -Encoding $enc
}
}

#Appel des fonctions ici, ajoutez une ligne par service à monitorer.

VerifServices -Service « WinRM »
VerifServices -Service « defragsvc »

Send-EmailServices</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Monitorer un Service Windows</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>New-SMBShare –Name "Shared" –Path "C:\MySharedFolder" `
–FullAccess domain\admingroup `
-ChangeAccess domain\FinanceUsers `
-ReadAccess "domain\authenticated users"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Partage d'un Dossier</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>#Recuperation Username distant :
$user = (Get-WmiObject -ComputerName $(Computer:TARGETHOSTNAME) -Class win32_computersystem).username.split("\")[1]

#Methode2
#Recuperation Username distant :
#$ComputerInfos = Get-WmiObject -Class Win32_ComputerSystem -Computername $(Computer:TARGET)
#[String] ${stUserDomain},[String] ${stUserAccount} = $ComputerInfos.Username.split("\")</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Récupération TargetUser PDQ</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>#Do Sh*t here

$Count = (gci c:\users| where {$_.PsIscontainer}).count
Write-Host "$Count"





#Back to PDQ
$computer = $env:Computername

$customfieldname = "Nb Dossiers Users Local"
$Customfieldtype = "String"    # Boolean, String, Integer, Date, or DateTime

$computerlist = @("ComputerName,$customfieldname")

$computer | ForEach-Object {

$computerlist += "$_,$Count"

}


$tempfile = New-TemporaryFile
$computerlist | out-file $tempfile

pdqinventory createcustomfield -name $customfieldname -type $customfieldtype
pdqinventory importcustomfields -filename $tempfile -computercolumn "ComputerName" -customfields "$Customfieldname=$customfieldname" -allowoverwrite</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Retour Output vers PDQ</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$Printer = "\\Printserv\Lexmark Chir"
Invoke-Command -Scriptblock {RUNDLL32 PRINTUI.DLL,PrintUIEntry /ga /n$Printer }

#Relance du spouleur pour affichage de l'imprimante
Set-Service -Name Spooler -StartupType Automatic
Stop-Service -name Spooler -Force
Start-service -name Spooler</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Add Mapped Printer</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>$Printer = "\\Printserv\SHARP MX-M264N PCL6"
Invoke-Command -Scriptblock {RUNDLL32 PRINTUI.DLL,PrintUIEntry /gd /n$Printer }</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Delete Mapped Printer</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Rem netsh interface set interface name="Wi-Fi" admin=DISABLED
netsh interface set interface name="Connexion réseau sans fil" admin=Disabled</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0050</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple WiFi Network Deconnection</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>netsh wlan add profile \\fileserv\Repository$\WiFi.xml
netsh wlan connect name="WiFi-Network"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Stock0050</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple WiFi Network Connection</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>#Par defaut, utilise un input file
#$InputFilePath = "C:\temp\Inputfile.csv" #Read-Host "Provide the Path of the inputfile without ("")"
#$Inputlist = import-csv $InputFilePath



########################################
#On bascule sur de la selection manuelle
#Creation / Recuperation des variables
#On cherche les groupes AD 'G_Ordinateurs*' et on affiche un menu de sélection:
$Groupes = Get-ADGroup -filter "name -like 'G_Ordinateurs*'" | Select Name,SID                   
$Menu = @{}
for ($Valeur=1;$Valeur -le $Groupes.count; $Valeur++) 
{Write-Host "$Valeur= $($Groupes[$Valeur-1])" 
$Menu.Add($Valeur,($Groupes[$Valeur-1]))}
[int]$Choix = Read-Host 'Choisir le Groupe AD: '
#Detection de choix non null pour poursuivre
If($Choix -eq "0") {
Write-Host "[INFO] Aucun groupe de choisi, le poste ne sera pas ajoute a un groupe, Abort ..!" -ForegroundColor Red
}
Else {
#On enregistre la sélection du menu
$Selection = $Menu.Item($Choix)
$GroupName = $Selection.Name
$GroupSID = $Selection.SID.Value
Write-Host "[INFO] On ajoute donc le groupe '$GroupName' avec le SID '$GroupSID' a notre commande !" -ForegroundColor Yellow
pause
}

#On cherche les imprimantes voulues, commencant par 'Copieur' sur Printserv2 on affiche un menu de sélection:
$Groupes2 = Get-Printer -Name "Copieur*" -ComputerName "Printserv"                 
$Menu2 = @{}
for ($Valeur=1;$Valeur2 -le $Groupes2.count; $Valeur2++) 
{Write-Host "$Valeur2= $($Groupes2[$Valeur2-1].Name)" 
$Menu2.Add($Valeur2,($Groupes2[$Valeur2-1].Name))}
[int]$Choix2 = Read-Host "Choisir l'imprimante: "
#Detection de choix non null pour poursuivre
If($Choix2 -eq "0") {
Write-Host "[INFO] Aucun groupe de choisi, le poste ne sera pas ajoute a un groupe, Abort ..!" -ForegroundColor Red
}
Else {
#On enregistre la sélection du menu
$Selection2 = $Menu2.Item($Choix2)
Write-Host "[RECAP] On ajoute donc l'imprimante '$Selection2' a notre commande !" -ForegroundColor Yellow
pause
}
Write-Host "[INFO] Debut de l'execution de la commande de creation de l'imprimante dans la GPO !" -ForegroundColor Yellow
#Here We go !
#On rassemble les données recuperees et go
$Inputlist = @([pscustomobject]@{Name="$Selection2";UserContext="1";Path="\\Printserv\$Selection2";GroupName="$Selection";GroupSID="$GroupSID";Action="U";GPOName="Name of the Printers GPO"})
$GPOName = $inputlist.GPOName |select -Unique
$FDRDatum = (Get-Date).tostring("yyyyMMdd")
# Provide Backup Folder path, the script will create a sub folder with current date.

$GPOBackupFDR = "C:\temp\$FDRDatum"

If(!(test-path $GPOBackupFDR))

    {
      New-Item -ItemType Directory -Path $GPOBackupFDR
        }

If (($GPOName).Count -eq 1)
                                                                                                
    {
        $GPOID = Get-GPO $GPOName |select ID
        Backup-GPO $GPOName -path $GPOBAckupFDR 
        # Provide the Network path of any DC to access the "Printer.xml" file. "Inly change the "\\DC\c$\" as per your environment. Rest remains same.
        $GPP_PRT_XMLPath =  "\\DC\c$\Windows\SYSVOL\domain\Policies\" + "{" + $GPOID.ID + "}" + "\User\Preferences\Printers\Printers.xml"
        [XML]$PRNT = (Get-Content -Path $GPP_PRT_XMLPath) 
        
            foreach ($e in  $Inputlist)

                {
                 $CurrentDateTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                 $newguid = [System.Guid]::NewGuid().toString()
                 $NewEntry = $PRNT.Printers.SharedPrinter[0].Clone() 
                 $NewEntry.Name = $e.Name
                 $NewEntry.Status = $e.Name 
                 $NewEntry.Changed = "$CurrentDateTime"
                 $NewEntry.uid = "{" + "$newguid" + "}"
                 #$NewEntry.userContext = $e.UserContext 
                 $NewEntry.properties.path = $e.Path
                 $NewEntry.properties.action = $e.action
                 $NewEntry.filters.Filtergroup.Name = $e.GroupName 
                 $NewEntry.filters.Filtergroup.SID = $e.GroupSID 
                 $PRNT.DocumentElement.AppendChild($NewEntry) 
                    } 

            $PRNT.Save($GPP_PRT_XMLPath)
                  Write-Host "[INFO] Commande correctement executee, l'imprimante a ete ajoutee au groupe selectionne !" -ForegroundColor Green
           }

Else {Write-Host -ForegroundColor Red "ERROR: GPOName not unique"}
Write-Host "La fenetre va se fermer dans 4 secondes."
Start-Sleep 4</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>LeaveShellOpen</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Add Printer to GPP</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine># Script to set up PowerShell and install the modules I use.
#
# This needs to be run with administrative priviledges
#

# A folder to create for temporary downloaded files.
$tempPath = 'C:\cbh09xewztcnyj3els2v\'

# The URL to the Skype Online PowerShell Module installer download.
$skypeUrl = "https://download.microsoft.com/download/2/0/5/2050B39B-4DA5-48E0-B768-583533B42C3B/SkypeOnlinePowerShell.Exe"

# The URL to the Exchange Online ClickOnce installer download.
$exoURL = 'https://cmdletpswmodule.blob.core.windows.net/exopsmodule/Microsoft.Online.CSE.PSModule.Client.application'

# Set the execution process to allow remotely signed scripts.
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Confirm:$false -Force

# Install NuGet package provider and mark PSGallery as trusted.
Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force
Set-PSRepository -Name PSGallery -InstallationPolicy Trusted

# Install modules available from PSGallery.
Install-Module -Name Az
Install-Module -Name AzureAD
Install-Module -Name Microsoft.Online.SharePoint.PowerShell
Install-Module -Name VMware.PowerCLI

# If the temp folder doesn't exist then create it, make a note whether we created it or not.
if (!(Test-Path -Path $tempPath)) {
    New-Item -Path $tempPath -ItemType Directory
    $newFolderCreated = $true
}
else {
    $newFolderCreated = $false
}

# Download and install the Skype Online PS module.
$skypePath = $tempPath + 'SkypeOnlinePowerShell.Exe'
Invoke-WebRequest -Uri $skypeUrl -OutFile $skypePath
Start-Process -Filepath $skypePath
Remove-Item -Path $skypePath

# Remove the temp folder if we created it.
if ($newFolderCreated) {
    Remove-Item -Path $tempPath
}

# Open Internet Explorer and trigger the EXO PS ClickOnce installer.
Start-Process -FilePath 'iexplore.exe' -ArgumentList $exoURL

# Write a bit of post install stuff to the screen.
Write-Output -InputObject ('It may be necessary to set up winrm, this can be done by running the following commands in an administrative command prompt:')
Write-Output -InputObject ('winrm quickconfig')
Write-Output -InputObject ('winrm set winrm/config/client/auth@{Basic="true"}')</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Installation Module Powershell pour script</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>Get-Content -Path "C:\Temp\toto.txt"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Get-Content of a file</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine># Set WinUserLanguageList as a variable
$lang = Get-WinUserLanguageList 
# Clear the WinUserLanguageList
$lang.Clear()
# Add language to the language list
$lang.add("fr-FR")
# Remove whatever input method is present
$lang[0].InputMethodTips.Clear()
# Add this keyboard as keyboard language
$lang[0].InputMethodTips.Add('040C:0000040C')
# Set this language list as default
Set-WinUserLanguageList $lang -Force
# Make region settings independent of OS language
Set-WinCultureFromLanguageListOptOut -OptOut $True
# Set region to this Country
Set-Culture "fr-FR"
# Set the location to this location
Set-WinHomeLocation -GeoId "84"
# Set non-unicode legacy software to use this language as default
Set-WinSystemLocale -SystemLocale "fr-FR"</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Icon-CommandStep</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Set Clavier FR</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Ajout d'un port TCP/IP pour une imprimante
$hostAddress = "111.111.111.111" 
$portNumber = "9100"  
$computer = $env:COMPUTERNAME
 
$wmi= [wmiclass]"\\$computer\root\cimv2:win32_tcpipPrinterPort" 
#$wmi.psbase.scope.options.enablePrivileges = $true 
$newPort = $wmi.createInstance() 
 
$newPort.hostAddress = $hostAddress 
$newPort.name = "IP_" + $hostAddress 
$newPort.portNumber = $portNumber 
$newPort.SNMPEnabled = $false 
$newPort.Protocol = 1 
$newPort.put()</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple ajout port TCP/IP pour imprimante</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>LocalSystem</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Remote</CustomToolType>
          <CommandLine>#Run this PowerShell script AS ADMIN. Image a mettre dans uns dossier

#Get a random image from a given folder...
$wallpapersFolder = "D:\Wallpapers\*"
$allWallpapers = Get-ChildItem $wallpapersFolder -Include *.jpg, *.png
$chosenWallpaper = Get-Random -InputObject $allWallpapers -Count 1
$newWallpaper = $chosenWallpaper.FullName
Write-Host "newWallpaper:" $newWallpaper

#Get the actual file name of the wallpaper...
$newWallPaperFilename = $newWallpaper.split("\")[-1]
Write-Host "newWallPaperFilename:" $newWallPaperFilename

#Get the expected wallpaper location from the existing registry kay...
#(The location is usually "C:\Windows\System32\oobe\info\backgrounds\")
$split = ((get-itemproperty HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System).wallpaper).split("\")
$wpFolder = (($split[0..($split.Length -2)]) -join "\") + "\"
Write-Host "wpFolder:" $wpFolder

#Copy the wallpaper file into the expected wallpaper location...
Copy-Item $newWallpaper $wpFolder -force

#Construct the registry key value for the new wallpaper path + filename...
$regValue = $wpFolder + $newWallPaperFilename
Write-Host "regValue:" $regValue

#Set registry value for new wallpaper path...
Set-ItemProperty -Path HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\ -Name wallpaper -Value $regValue

#Set wallpaper style...
#Styles: 0="Center", 1="Tile", 2="Stretch", 3="Fit", 4="Fill", 5="Span"
$wallpaperStyle = 2
Set-ItemProperty -Path HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\ -Name WallpaperStyle -Value $wallpaperStyle

#Restart the explorer process to view changes (the explorer process automatically restarts itself when it's stopped)...
Stop-Process -ProcessName explorer</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>PowerShell</Mode>
          <Description></Description>
          <IconKey>Icon-PowerShell</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Changement Wallpaper</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
        <CustomTool>
          <CredentialsId value="null" />
          <RunAs>Admin</RunAs>
          <ScanAfter>DoNotScan</ScanAfter>
          <ScanProfileId value="null" />
          <SuccessCodesText>0</SuccessCodesText>
          <Timeout>00:03:00</Timeout>
          <WakeOnLan value="false" />
          <CustomToolType>Local</CustomToolType>
          <CommandLine>Invoke-Command -ScriptBlock {pdqinventory ScanComputers -Computers "$(Computer:TARGET)" -ScanProfile "AD Infos"}</CommandLine>
          <DefaultIconKey></DefaultIconKey>
          <LibraryToolId value="null" />
          <Modified value="null" />
          <ShellOpenMode>ToolWindowCaptureOutput</ShellOpenMode>
          <Mode>Command</Mode>
          <Description></Description>
          <IconKey>Icon-CommandStep</IconKey>
          <KeyGesture></KeyGesture>
          <Title>Exemple Scan after action</Title>
          <TypeName>CustomTool</TypeName>
        </CustomTool>
      </Children>
    </FolderComputerTool>
    <SeparatorComputerTool>
      <Description></Description>
      <IconKey></IconKey>
      <KeyGesture></KeyGesture>
      <Title>Separator (2)</Title>
      <TypeName>SeparatorComputerTool</TypeName>
    </SeparatorComputerTool>
  </List>
</AdminArsenal.Export>